#+TITLE: AurÃ©lien Bottazini's Emacs configuration
#+OPTIONS: toc:4 h:4
#+PROPERTY: header-args :results silent :tangle yes

#+begin_src emacs-lisp :results silent
;; -*- lexical-binding: t; -*-
(defvar last-file-name-handler-alist file-name-handler-alist)
(setq gc-cons-threshold 402653184
      gc-cons-percentage 0.6
      file-name-handler-alist nil)

(add-hook 'emacs-startup-hook (lambda ()
(setq gc-cons-threshold 16777216
gc-cons-percentage 0.1
file-name-handler-alist last-file-name-handler-alist)))
#+end_src

I use Vim keybindings everywhere except with special modes
like Magit, Dired... I setup those special modes to start with Emacs
keybindings by default. If for any reason I encounter other modes
where the Vim keybindings are interfering too much, I can disable the
Vim keybindings with ~evil-toggle-key~.
#+BEGIN_SRC emacs-lisp
(setq evil-toggle-key "C-c e")
#+END_SRC

If Emacs complains about a mismatched paren while trying to start
you can use ~check-parens~
#+begin_src emacs-lisp :tangle no
(check-parens)
#+end_src

#+begin_src emacs-lisp :tangle yes
(toggle-debug-on-error)
#+end_src

* Setup
It is important to load custom settings first. Those are the ones
managed by Emacs through customization menus. They can impact the
loading of other packages.
#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load custom-file)
#+END_SRC

As I work on different computers, I need slightly different
settings. Instead of embedding machine specific code through
conditionals, I use a file to load machine specifics global
variables that are used in other parts of this configuration. I have
a small convention for the names. I surround them with double stars
and the name starts with local. Ex: ~(setq **local-my-variable**
"foo/bar")~.
#+BEGIN_SRC emacs-lisp
  (if (file-exists-p "~/.emacs.d/.emacs-local")
    (load "~/.emacs.d/.emacs-local"))
#+END_SRC

I keep elisp I write inside the site-lisp directory. The files
inside that directory are automatically added to the Emacs load-path.
#+BEGIN_SRC emacs-lisp
  (let ((default-directory  "~/.emacs.d/site-lisp/"))
    (normal-top-level-add-to-load-path '("."))
    (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

I use a special keymap ~my-keys-minor-mode-map~ where i store my global keybindings.
This is mainly to use a ~defadvice~ to make sure that any key I
define in my keymap as priority over ones defined elsewhere by
built-in Emacs modes or 3rd party packages
#+BEGIN_SRC emacs-lisp
  (defvar my-keys-minor-mode-map (make-keymap) "my-keys-minor-mode keymap.")
  (define-minor-mode my-keys-minor-mode
    "A minor mode so that my key settings override annoying major modes."
    t " my-keys" 'my-keys-minor-mode-map)
  (my-keys-minor-mode 1)

  (defadvice load (after give-my-keybindings-priority)
    "Try to ensure that my keybindings always have priority."
    (if (not (eq (car (car minor-mode-map-alist)) 'my-keys-minor-mode))
        (let ((mykeys (assq 'my-keys-minor-mode minor-mode-map-alist)))
          (assq-delete-all 'my-keys-minor-mode minor-mode-map-alist)
          (add-to-list 'minor-mode-map-alist mykeys))))
  (ad-activate 'load)
#+END_SRC

** Package library initialization
#+BEGIN_SRC emacs-lisp
(setq package-archives
      '(("melpa"       . "https://melpa.org/packages/")
        ("marmalade" . "http://marmalade-repo.org/packages/")
        ("gnu"         . "http://elpa.gnu.org/packages/")))

(setq package-user-dir (concat user-emacs-directory "elpa"))

(setq ;; this tells package.el not to add those pesky customized variable settings
      ;; at the end of your init.el
      package--init-file-ensured t)

(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))

(defun require-package (package &optional min-version)
  "Ask elpa to install given PACKAGE. You can specify a MIN-VERSION for your PACKAGE."
  (unless (package-installed-p package min-version)
    (package-install package)))

(require-package 'use-package)
(require 'use-package)
(setq use-package-compute-statistics t) ;; For (use-package-report)
(setq use-package-always-ensure t) ;; Install package if it is missing
#+END_SRC

You can get the time it took for emacs to start with.
It ~c-c c-c~ and it will show in the echo area.
#+BEGIN_SRC emacs-lisp :tangle no
   (emacs-init-time)
#+END_SRC

** Local variables
Local variables are useful to customize your settings for different
projects/directories. The built in ~make-local-variable~ is
convenient in helping you create those variables.

I find annoying when I edit those local variables
that they are not picked up automatically for open buffers. Those two
functions help me with the reloading of those locals.
#+BEGIN_SRC emacs-lisp
(defun my-reload-dir-locals-for-current-buffer ()
  "Reloads dir locals for the current buffer."
  (interactive)
  (let ((enable-local-variables :all))
    (hack-dir-local-variables-non-file-buffer)))

(defun my-reload-dir-locals-for-all-buffer-in-this-directory ()
  "For every buffer with the same `default-directory` as the current buffer's, reload dir-locals."
  (interactive)
  (let ((dir default-directory))
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (when (equal default-directory dir))
        (my-reload-dir-locals-for-current-buffer)))))
#+END_SRC

** Better Defaults
I like setting the path manually as other solutions like ~exec-path-from-shell~
slow down my Emacs.

#+BEGIN_SRC emacs-lisp
(setenv "JAVA_HOME" "/Library/Java/JavaVirtualMachines/adoptopenjdk-12.0.2.jdk/Contents/Home")
(let ((home-folder (getenv "HOME")))
  (setenv "PATH" (concat
                  "/home/linuxbrew/.linuxbrew/bin/:"
                  (concat home-folder "/.config/yarn/global/node_modules/.bin/:")
                  (concat home-folder "/.local/share/n/bin/:")
                  (concat home-folder "/.cargo/bin/:")
                  (concat home-folder "/.local/bin/:")
                  (concat home-folder "/work/dox-compose/bin/:")
                  (concat home-folder "/.rbenv/shims:")
                  (concat home-folder "/.rbenv/bin:")
                  (concat home-folder "/.fzf/bin:")
                  "/mnt/c/Windows/system32:"
                  "/usr/bin:"
                  "/usr/local/bin:"
                  "/bin"))

  (setq exec-path `(
                    "/home/linuxbrew/.linuxbrew/bin/"
                    ,(concat home-folder "/.config/yarn/global/node_modules/.bin/")
                    ,(concat home-folder "/work/dox-compose/bin/")
                    ,(concat home-folder "/.rbenv/bin/")
                    ,(concat home-folder "/.rbenv/shims/")
                    ,(concat home-folder "/dotfiles/bin/")
                    ,(concat home-folder "/.fzf/bin")
                    ,(concat home-folder "/.local/bin")
                    ,(concat home-folder "/bin")
                    "/usr/local/opt/node@10/bin/"
                    "/usr/local/bin"
                    "/bin/"
                    "/usr/local/sbin/"
                    "/usr/bin/")))
#+END_SRC

Emacs can be really fast with large files too. The trick is to
disable modes and stick to fundamental mode
#+BEGIN_SRC emacs-lisp
(defun check-large-file-hook ()
  "If a file is over a given size, turn off minor modes."
  (when (> (buffer-size) (* 1024 100)) ;; 100K
    (fundamental-mode)
    (font-lock-mode -1)
    (setq buffer-read-only t)
    (buffer-disable-undo)))

(add-hook 'find-file-hooks 'check-large-file-hook)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq help-window-select t)
(setq inhibit-startup-message t)
(setq delete-by-moving-to-trash t)
(setq tab-always-indent 'complete)
;; show end of buffer on left fringe
(setq-default default-indicate-empty-lines nil)
(make-variable-buffer-local 'compile-command)
(defalias 'yes-or-no-p 'y-or-n-p) ;; instead of typing yes or no, type y or n
(setq ring-bell-function 'ignore) ;; please don't startle me with a bell!

(setq backup-by-copying t      ; don't clobber symlinks
      backup-directory-alist
      '((".*" . "~/.local/share/emacs-saves"))    ; don't litter my fs tree
      delete-old-versions t
      kept-new-versions 6
      kept-old-versions 2
      auto-save-default t ;files starting with # are generated by autosave
      auto-save-timeout 60 ; number of seconds before auto-saving
      auto-save-interval 200 ; number of keystrokes before auto-saves
      version-control t) ; use versioned backups
(setq create-lockfiles nil)
(setq auto-save-file-name-transforms
      `((".*" ,"~/.local/share/emacs-saves" t)))

;; if file has no change, just load any changes
;; coming from an external process
(setq global-auto-revert-non-file-buffers t)
(global-auto-revert-mode 1)

;;; replace selected text when typing
(pending-delete-mode 1)

(prefer-coding-system 'utf-8)
(modify-coding-system-alist 'process "\\*compilation\\*\\'"   'utf-8)

;; gives each line only one visual line and don't show a continuation on next line
(set-default 'truncate-lines t)
#+END_SRC

Sentences end with one space after point. The default two space is
an historical setting. This makes Emacs sentence based commands more
understandable to me.
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

I want error highlights and error bindings in shell modes too.
#+BEGIN_SRC emacs-lisp
(add-hook 'shell-mode-hook 'compilation-shell-minor-mode)
#+END_SRC

~C-c C-w~ to copy regex
~C-c C-q~ to quit re-builder and to remove highlights
#+BEGIN_SRC emacs-lisp
(require 're-builder)
(setq reb-re-syntax 'string)
#+END_SRC

*** tabs and whitespace
By default I disable tabs. I use ~whitespace-mode~ in programming
buffers because sometimes when copy pasting code from external
sources those external sources have tabs. I want to see those tabs
to remove them.

I don't use the ~global-whitespace-mode~ as some emacs mode like
~magit~ use tabs.

You can remove all tabs from your buffer with ~untabify~
#+BEGIN_SRC emacs-lisp
(setq-default
 indent-tabs-mode nil    ;no tabs
 c-basic-offset 2)
(setq-default whitespace-style '(face trailing tabs tab-mark))
(add-hook 'before-save-hook 'delete-trailing-whitespace)
(add-hook 'prog-mode-hook 'whitespace-mode)
(eval-after-load "whitespace"
  '(diminish 'whitespace-mode))
#+END_SRC

*** Recent files
#+BEGIN_SRC emacs-lisp
(recentf-mode 1)
(setq recentf-max-menu-items 200)
(setq recentf-max-saved-items 200)
#+END_SRC

* Utility functions
#+BEGIN_SRC emacs-lisp
(defun slip-box()
  "Setup windows to work with my slip box"
  (interactive)
  (delete-other-windows)
  (find-file (concat **local-dropbox-folder** "org/slip-box/index.org"))
  (split-window-horizontally)
  (other-window 1)
  (find-file (concat **local-dropbox-folder** "org/slip-box/"))
  (other-window 1))

;; we can do the same with ivy, with M-o r
(defun sudo ()
  "Use TRAMP to `sudo' the file for current buffer."
  (interactive)
  (when buffer-file-name
    (find-alternate-file
     (concat "/sudo:root@localhost:"
             buffer-file-name))))

(defun enable-minor-mode (my-pair)
  "Enable minor mode if filename match the regexp.  MY-PAIR is a cons cell (regexp . minor-mode)."
  (if (buffer-file-name)
      (if (string-match (car my-pair) buffer-file-name)
          (funcall (cdr my-pair)))))

(defun filepath-with-line-number-for-current-buffer ()
  "Return a string with Buffer-file-name:line-number.
             Make it easier to prepare commands for tools like rspec"
  (interactive)
  (concat (buffer-file-name) ":" (number-to-string (line-number-at-pos))))

(defun add-date-to-filename ()
  "Add current date in front of filename for current buffer. This is useful with some
        Blog tools like Jekyll to publish new articles."
  (interactive)
  (let* ((date (format-time-string "%Y-%m-%d"))
         (buffer-file (buffer-file-name))
         (new-file-name (concat (file-name-directory buffer-file)
                                date
                                "-"
                                (file-name-nondirectory buffer-file)))
         )
    (rename-file buffer-file new-file-name)
    (set-visited-file-name new-file-name)
    (save-buffer)))

(defun toggle-html-export-on-save ()
  "Enable or disable HTML export when saving current org buffer."
  (interactive)
  (when (not (eq major-mode 'org-mode))
    (error "Not an org-mode file!"))
  (if (memq 'org-html-export-to-html after-save-hook)
      (progn (remove-hook 'after-save-hook 'org-html-export-to-html t)
             (message "Disabled org html export on save"))
    (add-hook 'after-save-hook 'org-publish-current-file nil t)
    (set-buffer-modified-p t)
    (message "Enabled org html export on save")))


(defun abo-jump-to-note-file ()
  "Jump to org note file for current buffer"
  (interactive)
  (find-file **local-note-file**))
(define-key my-keys-minor-mode-map "\C-cn" 'abo-jump-to-note-file)

(defun abo-change-line-endings-to-unix ()
  (let ((coding-str (symbol-name buffer-file-coding-system)))
    (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
      (set-buffer-file-coding-system 'unix))))

(add-hook 'find-file-hooks 'abo-change-line-endings-to-unix)
#+END_SRC

* GUI
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
(column-number-mode)

(electric-indent-mode t)

(electric-pair-mode)
(defun inhibit-electric-pair-mode-in-minibuffer (char)
  (minibufferp))
(setq electric-pair-inhibit-predicate #'inhibit-electric-pair-mode-in-minibuffer)

(setq frame-title-format "emacs")

(define-key my-keys-minor-mode-map (kbd "C-c op") 'show-paren-mode)
(setq blink-matching-paren 'jump-offscreen)

;; makes fringe big enough with HDPI
(when (boundp 'fringe-mode)
  (fringe-mode 20))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package diminish
  :config
  (eval-after-load "undo-tree"
    '(diminish 'undo-tree-mode))
    (eval-after-load "subword"
    '(diminish 'subword-mode))
  (diminish 'auto-fill-function)
  (diminish 'my-keys-minor-mode)
  (diminish 'eldoc-mode))
#+END_SRC
** Colors
*** Emacs defaults

| face     | color        | Hex     |
|----------+--------------+---------|
| comment  | Firebrick    | #b22222 |
| constant | Dark Cyan    | #008b8b |
| function | Blue1        | #0000ff |
| keyword  | purple       | #a020f0 |
| string   | violetred4   | #8b2252 |
| type     | forest green | #228b22 |
| variable | sienna       | #a0522d |
| error    | red1         | #ff0000 |

*** [[https://gist.github.com/aurelienbottazini/63b6fbd69e570374975a8b3b86798dae][Ansi colors for a light terminal]]
* Windows
Splitting can be done with ~C-x 2~ and ~C-x 3~ but I prefer more
memorable keybindings.
#+BEGIN_SRC emacs-lisp
(define-key my-keys-minor-mode-map (kbd "C-c \\") 'split-window-right)
(define-key my-keys-minor-mode-map (kbd "C-c -") 'split-window-below)
#+END_SRC

Move between buffers with C-h C-j C-k C-l. My Tmux bindings are made
to [[file:~/dotfiles/tmux/.tmux.conf::is_vim_or_emacs='echo%20"#{pane_current_command}"%20|%20grep%20-iqE%20"vim|emacs|reattach-to-user-namespace"'%20bind%20-n%20C-h%20if-shell%20"$is_vim_or_emacs"%20"send-keys%20C-h"%20"select-pane%20-L"%20bind%20-n%20C-j%20if-shell%20"$is_vim_or_emacs"%20"send-keys%20C-j"%20"select-pane%20-D"%20bind%20-n%20C-k%20if-shell%20"$is_vim_or_emacs"%20"send-keys%20C-k"%20"select-pane%20-U"%20bind%20-n%20C-l%20if-shell%20"$is_vim_or_emacs"%20"send-keys%20C-l"%20"select-pane%20-R"][make it work seamlessly]] with Emacs.
#+BEGIN_SRC emacs-lisp
(defun tmux-socket-command-string ()
  (interactive)
  (concat "tmux -S "
          (replace-regexp-in-string "\n\\'" ""
                                    (shell-command-to-string "echo $TMUX | sed -e 's/,.*//g'"))))

(defun tmux-move-right ()
  (interactive)
  (condition-case nil
      (evil-window-right 1)
    (error (unless window-system (shell-command (concat
                                                 (tmux-socket-command-string) " select-pane -R") nil)))))

(defun tmux-move-left ()
  (interactive)
  (condition-case nil
      (evil-window-left 1)
    (error (unless window-system (shell-command (concat
                                                 (tmux-socket-command-string) " select-pane -L") nil)))))

(defun tmux-move-up ()
  (interactive)
  (condition-case nil
      (evil-window-up 1)
    (error (unless window-system (shell-command (concat
                                                 (tmux-socket-command-string) " select-pane -U") nil)))))

(defun tmux-move-down ()
  (interactive)
  (condition-case nil
      (evil-window-down 1)
    (error (unless window-system (shell-command (concat
                                                 (tmux-socket-command-string) " select-pane -D") nil)))))

(define-key my-keys-minor-mode-map (kbd "C-h") 'tmux-move-left)
(define-key my-keys-minor-mode-map (kbd "C-j") 'tmux-move-down)
(define-key my-keys-minor-mode-map (kbd "C-k") 'tmux-move-up)
(define-key my-keys-minor-mode-map (kbd "C-l") 'tmux-move-right)
#+END_SRC
* Programming languages

#+BEGIN_SRC emacs-lisp
(defun my-prog-mode-auto-fill-hook ()
  (setq fill-column 80)
  (set (make-local-variable 'comment-auto-fill-only-comments) t)
  (auto-fill-mode t))
(add-hook 'prog-mode-hook 'my-prog-mode-auto-fill-hook)
#+END_SRC

** Clojure
#+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :mode "\\.clj\\'"
  :config
  (add-hook 'clojure-mode-hook #'subword-mode)
  (use-package cider))
#+END_SRC
** Ruby
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :mode "\\.ya?ml\\'")

(use-package ruby-mode
  :mode "\\.rake\\'"
  :mode "Rakefile\\'"
  :mode "\\.gemspec\\'"
  :mode "\\.ru\\'"
  :mode "Gemfile\\'"
  :mode "Guardfile\\'"
  :mode "Capfile\\'"
  :mode "\\.cap\\'"
  :mode "\\.thor\\'"
  :mode "\\.rabl\\'"
  :mode "Thorfile\\'"
  :mode "Vagrantfile\\'"
  :mode "\\.jbuilder\\'"
  :mode "Podfile\\'"
  :mode "\\.podspec\\'"
  :mode "Puppetfile\\'"
  :mode "Berksfile\\'"
  :mode "Appraisals\\'"
  :mode "\\.rb$"
  :mode "ruby"
  :config

  (add-hook 'ruby-mode-hook 'subword-mode)

  (define-key ruby-mode-map (kbd "C-c C-c") 'xmp)
  (use-package ruby-interpolation
    :diminish ruby-interpolation-mode)
  (use-package ruby-end
    :diminish ruby-end-mode
    :config
    (defun ruby-end-insert-end ()
      "Closes block by inserting end."
      (save-excursion
        (newline)
        (insert "end")
        (indent-according-to-mode)))
    )
  (use-package rspec-mode))
#+END_SRC

I learned about this on [[http://www.virtuouscode.com/2013/06/24/rubytapas-freebie-xmpfilter/][Ruby Tapas.]] Hit ~M-;~ twice adds a special
comment for xmpfilter. Running ~xmp~ will evaluate the line and put
the result after the comment.
#+BEGIN_SRC emacs-lisp
(require 'rcodetools)
(defadvice comment-dwim (around rct-hack activate)
    "If comment-dwim is successively called, add => mark."
    (if (and (or (eq major-mode 'enh-ruby-mode)
                 (eq major-mode 'ruby-mode))
             (eq last-command 'comment-dwim))
        (progn
          (if (eq major-mode 'enh-ruby-mode)
              (end-of-line))
          (insert "=>"))
      ad-do-it))
#+END_SRC
** Go

#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :mode "\\.go\\'")
#+END_SRC

** HTML

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode "\\.html\\'"
  :mode "\\.gohtml\\'"
  :config
  (setq web-mode-enable-auto-closing t))

(use-package emmet-mode
  :hook (css-mode sgml-mode web-mode)
  :after evil
  :diminish emmet-mode
  :config
  (progn
    (evil-define-key 'insert emmet-mode-keymap (kbd "C-j") 'emmet-expand-line)
    (evil-define-key 'emacs emmet-mode-keymap (kbd "C-j") 'emmet-expand-line))

  (add-hook 'css-mode-hook
            (lambda ()
              (emmet-mode)
              (setq emmet-expand-jsx-className? nil)))

  (add-hook 'sgml-mode-hook
            (lambda ()
              (emmet-mode)
              (setq emmet-expand-jsx-className? nil)))
              )
#+END_SRC

** CSS
#+BEGIN_SRC emacs-lisp
(use-package scss-mode
  :mode "\\.scss\\'")

(use-package sass-mode :mode "\\.sass\\'")

(use-package less-css-mode
  :mode "\\.less\\'")
#+END_SRC
** JavaScript
Node compilation errors messages are not understood by Emacs by
default. All that's needed to make it work is to add a new regex
describing what are the components of the messages.

After running the compile command, you can navigate through the
errors with ~next-error~ and ~previous-error~
#+BEGIN_SRC emacs-lisp
(require 'compile)
(setq compilation-error-regexp-alist-alist
      (cons '(node "^\\([a-zA-Z\.0-9\/-]+\\):\\([0-9]+\\)$"
                   1 ;; file
                   2 ;; line
                   )
            compilation-error-regexp-alist-alist))
(setq compilation-error-regexp-alist
      (cons 'node compilation-error-regexp-alist))

(add-hook 'js2-mode-hook
          (lambda ()
            (set (make-local-variable 'compile-command)
                 (format "node %s" (file-name-nondirectory buffer-file-name)))))

#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq js-indent-level 2)

(use-package js2-mode
  :mode "\\.js\\'"
  :mode "\\.jsx\\'"
  :config
  (setq js2-mode-show-parse-errors nil
        js2-mode-show-strict-warnings nil
        js2-basic-offset 2
        js2-highlight-level 3
        css-indent-offset 2
        web-mode-markup-indent-offset 2
        web-mode-script-padding 0
        web-mode-css-indent-offset 2
        web-mode-style-padding 2
        web-mode-code-indent-offset 2
        web-mode-attr-indent-offset 2)
  :config
  (add-hook 'js2-mode-hook 'js2-imenu-extras-mode)
  (add-hook 'js2-mode-hook (lambda() (subword-mode t)))

  ;; (use-package xref-js2
  ;;   :init
  ;;   (setq xref-js2-search-program 'rg)
  ;;   :config
  ;;   (add-hook 'js2-mode-hook (lambda () (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t))))

(use-package json-mode
  :mode "\\.json\\'"
  :mode "\\.eslintrc\\'")

(use-package coffee-mode
  :mode "\\.coffee\\'"
  :config
  (use-package highlight-indentation)
  (add-hook 'coffee-mode-hook '(lambda () (highlight-indentation-mode)))
  (add-hook 'coffee-mode-hook '(lambda () (subword-mode +1)))
  (custom-set-variables '(coffee-tab-width 2)))

(use-package typescript-mode
  :mode "\\.ts\\'")
#+END_SRC

Auto-format JavaScript on save
#+BEGIN_SRC emacs-lisp
   (use-package prettier-js
     :diminish prettier-js-mode
     :config
     (setq prettier-args '(
                           "--trailing-comma" "es5"
                           "--single-quote" "true"
                           )
           prettier-js-command "prettier")
     (add-hook 'js2-mode-hook #'js2-imenu-extras-mode)
     (add-hook 'js2-mode-hook 'prettier-js-mode))
#+END_SRC

Context-coloring highlights code based on closures.
This gives a refreshing view of the code and helps using closures
efficiently.
#+BEGIN_SRC emacs-lisp
   (use-package context-coloring
     :ensure t
     :diminish context-coloring-mode
     :bind (:map my-keys-minor-mode-map ("C-c oc" . context-coloring-mode))
     :config
     (add-hook 'js2-mode-hook 'context-coloring-mode))
#+END_SRC

*** React

The following shows a pretty interesting way to quickly create
major modes _magically_. It parses the file to detect if this is a
react file. If yes I run a function to use web-mode and make some
adjustments for JSX.
#+BEGIN_SRC emacs-lisp
(add-to-list 'magic-mode-alist '("^import.*React.* from 'react'" . my-jsx-hook) )
(defun my-jsx-hook ()
  "Set web mode with adjustments for JSX"
  (interactive)
  (web-mode)
  (web-mode-set-content-type "jsx")
  (setq emmet-expand-jsx-className? t)
  (emmet-mode)))

(use-package prettier-js
  :config
  (add-hook 'web-mode-hook #'(lambda ()
                               (enable-minor-mode
                                '("\\.jsx?\\'" . prettier-js-mode)))))
#+END_SRC
*** Vue
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode "\\.vue\\'"
  :config
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2)
  (setq web-mode-script-padding 0)
  (defun jjpandari/merge-imenu (index-fun)
    (interactive)
    (let ((mode-imenu (funcall index-fun))
          (custom-imenu (imenu--generic-function imenu-generic-expression)))
      (append custom-imenu mode-imenu)))

  (use-package prettier-js
    :config
    (add-hook 'web-mode-hook #'(lambda ()
                                 (enable-minor-mode
                                  '("\\.vue?\\'" . prettier-js-mode)))))

  (add-hook 'web-mode-hook
            (lambda ()
              (setq imenu-create-index-function (lambda () (jjpandari/merge-imenu 'web-mode-imenu-index))))))

(require 'aurayb-narrow-indirect-vue)
;; (define-key my-keys-minor-mode-map (kbd "nj") (aurayb-make-narrow-indirect-vue "script" 'js2-mode))
;; (define-key my-keys-minor-mode-map (kbd "nh") (aurayb-make-narrow-indirect-vue "template" 'html-mode))
;; (define-key my-keys-minor-mode-map (kbd "ns") (aurayb-make-narrow-indirect-vue "style" 'scss-mode))
;; (define-key my-keys-minor-mode-map (kbd "nn") '(lambda () (interactive) (pop-to-buffer-same-window (buffer-base-buffer))))
#+END_SRC
* Docker
#+BEGIN_SRC emacs-lisp
(use-package docker
 :ensure t
 :bind ("C-c d d". docker)
 :config
    (defadvice docker-image-mode (after docker-image-mode-change-to-emacs-state activate compile)
      "when entering git-timemachine mode, change evil normal state to emacs state"
      (if (evil-normal-state-p)
          (evil-emacs-state)
        (evil-normal-state))))

;; (use-package transient)
;; (require 'dox-dc)
;; (define-key my-keys-minor-mode-map (kbd "C-c d x") (dox-dc))
;; (evil-set-initial-state 'dox-dc-mode 'emacs)
#+END_SRC
* Flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :diminish flycheck-mode
  :init
  (add-hook 'web-mode-hook 'flycheck-mode)
  (add-hook 'js2-mode-hook 'flycheck-mode)
  (add-hook 'cfn-mode-hook 'flycheck-mode)
  :config
  (flycheck-add-mode 'javascript-eslint 'web-mode)
  (defun my/use-eslint-from-node-modules ()
    (let* ((root (locate-dominating-file
                  (or (buffer-file-name) default-directory)
                  "node_modules"))
           (eslint (and root
                        (expand-file-name "node_modules/eslint/bin/eslint.js"
                                          root))))
      (when (and eslint (file-executable-p eslint))
        (setq-local flycheck-javascript-eslint-executable eslint))))
  (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)

(define-derived-mode cfn-mode yaml-mode
  "Cloudformation"
  "Cloudformation template mode.")
(add-to-list 'auto-mode-alist '(".template.yaml\\'" . cfn-mode))
(flycheck-define-checker cfn-lint
  "A Cloudformation linter using cfn-python-lint.
            See URL 'https://github.com/awslabs/cfn-python-lint'."
  :command ("cfn-lint" "-f" "parseable" source)
  :error-patterns (
                   (warning line-start (file-name) ":" line ":" column
                            ":" (one-or-more digit) ":" (one-or-more digit) ":"
                            (id "W" (one-or-more digit)) ":" (message) line-end)
                   (error line-start (file-name) ":" line ":" column
                          ":" (one-or-more digit) ":" (one-or-more digit) ":"
                          (id "E" (one-or-more digit)) ":" (message) line-end)
                   )
  :modes (cfn-mode))
(add-to-list 'flycheck-checkers 'cfn-lint))

#+END_SRC
* Bindings
** General
Shows a key combination helper in the minibuffer
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :diminish which-key-mode
  :config
  (which-key-mode))
#+END_SRC

~recursived-edit~, combined with C-M-c (exit-recursive-edit),
allows to stop doing something momentarily, do something else and
come back to it later.
#+BEGIN_SRC emacs-lisp
(define-key my-keys-minor-mode-map (kbd "C-M-e") 'recursive-edit)
#+END_SRC

Make grep buffers writable with ~C-c C-p~. Apply changes with ~C-c C-e~
#+BEGIN_SRC emacs-lisp
;; makes grep buffers writable and apply the changes to files.
(use-package wgrep :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package paredit
  :diminish paredit-mode
  :bind (:map my-keys-minor-mode-map
         ("C-c 0" . paredit-forward-slurp-sexp)
         ("C-c 9" . paredit-backward-slurp-sexp)
         ("C-c ]" . paredit-forward-barf-sexp)
         ("C-c [" . paredit-backward-barf-sexp))
  :config
  (add-hook 'emacs-lisp-mode-hook #'paredit-mode))

(use-package expand-region
  :bind (:map my-keys-minor-mode-map ("C-c w" . er/expand-region)))

(define-key my-keys-minor-mode-map (kbd "C-c a") 'org-agenda)
(define-key my-keys-minor-mode-map (kbd "C-c R") 'revert-buffer)
(define-key my-keys-minor-mode-map (kbd "C-c jc") 'org-clock-jump-to-current-clock)
(define-key my-keys-minor-mode-map (kbd "C-c je") '(lambda () (interactive) (find-file "~/dotfiles/emacs/.emacs.d/init.org")))
(define-key my-keys-minor-mode-map (kbd "C-c jp") '(lambda () (interactive) (find-file "~/projects/")))
(define-key my-keys-minor-mode-map (kbd "C-c jw") '(lambda () (interactive) (find-file "~/work")))
(define-key my-keys-minor-mode-map (kbd "C-c jn") '(lambda () (interactive) (find-file **local-note-file**)))
(define-key my-keys-minor-mode-map (kbd "C-c js") 'slip-box)
(define-key my-keys-minor-mode-map (kbd "C-c ji") '(lambda () (interactive) (find-file (concat **local-dropbox-folder** "org/slip-box/index.org"))))
(define-key my-keys-minor-mode-map (kbd "C-c jr") '(lambda () (interactive) (find-file (concat **local-dropbox-folder** "org/references-notes"))))
(define-key my-keys-minor-mode-map (kbd "C-c jj") 'dired-jump)
(define-key my-keys-minor-mode-map (kbd "C-c k") 'recompile)
(define-key my-keys-minor-mode-map (kbd "C-c K") 'compile)

(define-key my-keys-minor-mode-map (kbd "<f5>") 'ispell-buffer)

(define-key my-keys-minor-mode-map (kbd "C-c h") 'highlight-symbol-at-point)
(define-key my-keys-minor-mode-map (kbd "C-c H") 'unhighlight-regexp)
(define-key my-keys-minor-mode-map (kbd "C-c oh") '(lambda ()
  (interactive)
  (hi-lock-mode -1)
  (evil-search-highlight-persist-remove-all)))

(defun hide-line-numbers ()
  (interactive)
  (setq display-line-numbers (quote nil)))
(define-key my-keys-minor-mode-map (kbd "C-c olh") 'hide-line-numbers)

(defun show-line-numbers ()
  (interactive)
  (setq display-line-numbers (quote absolute)))
(define-key my-keys-minor-mode-map (kbd "C-c oll") 'show-line-numbers)
(define-key my-keys-minor-mode-map (kbd "C-c ow") 'visual-line-mode)
(define-key my-keys-minor-mode-map (kbd "C-c of") 'auto-fill-mode)
(define-key my-keys-minor-mode-map (kbd "C-c og") 'global-hl-line-mode)

(use-package rainbow-mode
  :diminish rainbow-mode
  :bind (:map my-keys-minor-mode-map
              ("C-c or" . rainbow-mode)))

(define-key my-keys-minor-mode-map (kbd "C-c ot") 'toggle-truncate-lines)

(use-package evil
  :config
   (define-key evil-normal-state-map (kbd "[b") 'previous-buffer)
   (define-key evil-normal-state-map (kbd "]b") 'next-buffer)
   (define-key evil-normal-state-map (kbd "]e") 'next-error)
   (define-key evil-normal-state-map (kbd "[e") 'previous-error))

(use-package windresize
  :bind (:map evil-normal-state-map
              ("C-w r" . windresize)))
#+END_SRC
** Drag stuff
#+BEGIN_SRC emacs-lisp
(use-package drag-stuff
  :diminish t
  :bind (:map my-keys-minor-mode-map
         ("C-M-<up>" . drag-stuff-up)
         ("C-M-<down>" . drag-stuff-down))
  :config
  (drag-stuff-global-mode t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package key-chord
  :defer 2
  :after evil
  :config
  (key-chord-mode 1)
  (key-chord-define evil-insert-state-map  "jk" 'evil-normal-state))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package evil
  :config
  (evil-define-key 'insert lisp-interaction-mode-map (kbd "C-j") 'eval-print-last-sexp))
#+END_SRC

* Notes

Some people switch to Emacs just to use org-mode.

It is one of the best tool for note taking and writing

Setting the org-directory helps integration with org-agenda and
for org template captures.
#+BEGIN_SRC emacs-lisp
(setq org-directory **local-org-folder**)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'turn-on-auto-fill)

(add-hook 'org-capture-mode-hook 'evil-insert-state)

(use-package evil
  :init
  (setq org-use-speed-commands nil)
  :config
  (evil-define-key 'normal org-mode-map
    (kbd "M-l") 'org-shiftmetaright
    (kbd "M-h") 'org-shiftmetaleft
    (kbd "M-k") 'org-move-subtree-up
    (kbd "M-j") 'org-move-subtree-down
    (kbd "M-p") 'org-publish-current-project
    (kbd "TAB") 'org-cycle)
  )
(require 'org)
(add-to-list 'org-modules "org-habit")
(setq org-log-into-drawer t)

(setq org-todo-keywords
      '((sequence "TODO" "WAITING" "|" "DONE(!)")))
#+END_SRC



** Navigate Notes
#+begin_src emacs-lisp :results silent
(use-package deft
 :bind (:map my-keys-minor-mode-map
             ("<f9>" . deft))
 :commands (deft)
 :config
 (setq deft-extensions '("org" "md")
       deft-recursive t
       deft-directory **local-deft-directory**))
#+end_src
** References
#+begin_src emacs-lisp :results silent :tangle yes
(use-package org-ref
  :defer 2
  :config
  (setq reftex-default-bibliography `(,(concat **local-org-folder** "/references.bib")))

  ;; see org-ref for use of these variables
  (setq org-ref-bibliography-notes (concat **local-org-folder** "/references-notes/")
        org-ref-default-bibliography `(,(concat **local-org-folder** "/references.bib"))
        org-ref-pdf-directory (concat **local-org-folder** "/bibtex-pdfs/"))
  (require 'org-ref-pdf)
  (require 'org-ref-url-utils)
  (require 'org-ref-isbn)
  (require 'org-ref-bibtex))

(use-package ivy-bibtex
  :bind (:map my-keys-minor-mode-map
             ("C-c B" . ivy-bibtex))
  :config
  (setq ivy-bibtex-default-action 'ivy-bibtex-insert-citation)
  (setq bibtex-completion-bibliography reftex-default-bibliography)
  (setq bibtex-completion-notes-path (concat **local-org-folder** "/references-notes/")))
#+end_src

** Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
 :mode "\\.md\\'")
#+END_SRC
** Capture Ideas

~C-c l~ to store a link and ~C-c C-l~ to insert that link.

If you have a selection, it will be part of the link and Emacs will
actually look for that selection If you visit the link.
#+BEGIN_SRC emacs-lisp
   (define-key my-keys-minor-mode-map "\C-cl" 'org-store-link)
#+END_SRC

Palimpsest makes it easier to quickly discard blocks of text.
Main use is to just send the block of text at the bottom of the
buffer. This way I can revise my writing without losing my drafts.
~C-c C-q~ move region to trash
~C-c C-r~ move region to bottom
#+BEGIN_SRC emacs-lisp
(use-package palimpsest
  :diminish palimpsest-mode
  :config
  (add-hook 'org-mode-hook 'palimpsest-mode))
#+END_SRC

org-capture allows to set up templates for quick note taking.
This is a must to capture ideas quickly.
#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
       '(("n" "Notes" entry (file+headline **local-note-file** "Inbox") "* %?\n")))

(define-key my-keys-minor-mode-map (kbd "C-c n") '(lambda () (interactive) (org-capture nil "n")))
(add-hook 'org-capture-mode-hook 'evil-insert-state)
#+END_SRC

To launch an Emacs client with a capture frame selecting the ~n~ template
~emacsclient -ca "" --frame-parameters='(quote (name .
"global-org-capture"))' -e '(org-capture nil "n")'~.

It works nicely on Linux, however on Mac the focus and input focus
is sketchy and is not reliable.

The following takes advantage that I name those capture frame
~global-org-capture~ to do some housekeeping around them
#+BEGIN_SRC emacs-lisp
(defadvice org-capture-finalize
    (after delete-capture-frame activate)
  "Advise capture-finalize to close the frame"
  (if (equal "global-org-capture" (frame-parameter nil 'name))
      (progn
        (delete-frame))))

(defadvice org-capture-destroy
    (after delete-capture-frame activate)
  "Advise capture-destroy to close the frame"
  (if (equal "global-org-capture" (frame-parameter nil 'name))
      (progn
        (delete-frame))))

;; make the frame contain a single window. by default org-capture
;; splits the window.
(add-hook 'org-capture-mode-hook
          'delete-other-windows)
#+END_SRC

** Inline Code

Org babel allows to evaluate code snippets inside org files.
This is the best way I know of doing [[https://en.wikipedia.org/wiki/Literate_programming][Literate Programming]]

This loads more programming languages to use with org-babel.
#+BEGIN_SRC emacs-lisp
(require 'ob-clojure) ;; run cider-jack-in from org buffer to be able to run
                      ;; clojure code
(use-package ob-clojurescript) ;; requires [[https://github.com/anmonteiro/lumo][lumo]]
(setq org-babel-clojure-backend 'cider)
(require 'ob-js)
(setq org-babel-js-function-wrapper "require('util').log(require('util').inspect(function(){%s}()));")
(org-babel-do-load-languages 'org-babel-load-languages
                             '((shell . t)
                               (ditaa . t)))
(setq org-ditaa-jar-path "/usr/local/Cellar/ditaa/0.11.0/libexec/ditaa-0.11.0-standalone.jar")
#+END_SRC

** Publish
My strategy is to keep my writings in the same folder
~$HOME/Dropbox/org/writing~ and run ~org-publish-current-file~ or
~org-publish~ to export to HTML.

The HTML export has just the body. I then use a tool like ~jekyll~
or ~hugo~ to make it accessible on internet.
#+BEGIN_SRC emacs-lisp
(setq
 time-stamp-active t
 time-stamp-line-limit 30     ; check first 30 buffer lines for Time-stamp:
 time-stamp-format "%04y-%02m-%02d") ;

(use-package writeroom-mode
  :bind (:map my-keys-minor-mode-map
              ("C-c z" . writeroom-mode)))

(setq org-src-preserve-indentation nil
      org-html-indent nil
      org-edit-src-content-indentation 0)
(use-package htmlize :defer 2) ;; for org html export
(setq system-time-locale "C") ;; make sure time local is in english when exporting
(setq org-html-validation-link nil)
(setq org-publish-project-alist
      '(
        ("blog-files"
         :base-directory **local-blog-folder**
         :base-extension "org"
         :publishing-directory **local-blog-exported-folder**
         :recursive t
         :publishing-function org-html-publish-to-html
         :headline-levels 4             ; Just the default for this project.
         :auto-preamble t
         :html-head nil
         :html-head-extra nil
         :body-only true
         )
        ;; ... add all the components here (see below)...
        ;; ("wiki" :components ("wiki-files"))
        )
      org-export-with-toc nil
      org-html-doctype "html5"
      org-html-head nil
      org-html-head-include-default-style nil
      org-html-head-include-scripts nil
      org-html-html5-fancy t
      org-html-postamble nil
      org-html-indent t)

(add-hook 'org-mode-hook
          (lambda ()
            (setq-local time-stamp-start "Updated on[ 	]+\\\\?[\"<]+")
            (org-indent-mode t)
            (add-hook 'before-save-hook 'time-stamp nil 'local)))

(add-hook 'write-file-hooks 'time-stamp) ; update when saving
(require 'ox-publish)
(setq system-time-locale "C") ;; make sure time local is in english when exporting
(setq org-html-validation-link nil)
#+END_SRC

** Feedback

Ispell buffer with ~F5~
Ispell word with ~z =~
#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "aspell")
(setq ispell-silently-savep t)
(setq ispell-personal-dictionary **local-personal-dictionary**)
;; Please note ispell-extra-args contains ACTUAL parameters passed to aspell
(setq ispell-extra-args '("--sug-mode=ultra" "--lang=en_US"))

(add-hook 'org-mode-hook 'turn-on-flyspell)
(eval-after-load "flyspell"
     '(diminish 'flyspell-mode))
#+END_SRC

Word definition
#+BEGIN_SRC emacs-lisp
(use-package define-word
  :bind (:map evil-normal-state-map
          ("zw" . define-word-at-point)))
#+END_SRC

Word synonyms.
#+BEGIN_SRC emacs-lisp
(use-package powerthesaurus
  :bind (:map evil-normal-state-map
          ("zs" . powerthesaurus-lookup-word-dwim)))
#+END_SRC

For most documents, aim for a score of approximately 60 to 70 for
the reading ease and 7.0 to 8.0 for the grade level.
#+BEGIN_SRC emacs-lisp
(use-package writegood-mode
 :bind (:map evil-normal-state-map
 (
         ("zgg" . writegood-mode)
         ("zgr" . writegood-reading-ease)
         ("zgl" . writegood-grade-level)
  )))
#+END_SRC

If you need additional feedback from an external service here is an
easy way to do it:
#+BEGIN_SRC emacs-lisp
(require 'browse-url) ; part of gnu emacs

(defun my-lookup-wikipedia ()
  "Look up the word under cursor in Wikipedia.
If there is a text selection (a phrase), use that.

This command switches to browser."
  (interactive)
  (let (word)
    (setq word
          (if (use-region-p)
              (buffer-substring-no-properties (region-beginning) (region-end))
            (current-word)))
    (setq word (replace-regexp-in-string " " "_" word))
    (browse-url (concat "http://en.wikipedia.org/wiki/" word))
    ;; (eww myUrl) ; emacs's own browser
    ))
#+END_SRC
* Vim
I started using Vim to help me prevent [[https://www.emacswiki.org/emacs/RepeatedStrainInjury][emacs RSI.]]
Now I am sticking with it because It makes me feel like beethoven
manipulating text :-)

Here is an awesome [[https://github.com/noctuid/evil-guide][Evil Guide]]

Quit read-only windows with Q instead of trying to register a Vim
Macro.
This is mainly to restore emacs behavior with help windows.
#+BEGIN_SRC emacs-lisp
(use-package evil
  :config
  (defun my-evil-record-macro ()
    (interactive)
    (if buffer-read-only
        (quit-window)
      (call-interactively 'evil-record-macro)))

  (with-eval-after-load 'evil-maps
    (define-key evil-normal-state-map (kbd "q") 'my-evil-record-macro)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package evil-easymotion)
#+END_SRC

Surround things with
- ~S~ in visual mode
- ~ys<text-object>~ in normal mode
  You can also change surroundings ~cs~ or delete surroundings ~ds~.
  #+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :after evil
    :config
    (global-evil-surround-mode 1))
  #+END_SRC

  Comment things with ~gc~. Comment and copy with ~gy~
  #+BEGIN_SRC emacs-lisp
  (use-package evil-commentary
    :after evil
    :diminish evil-commentary-mode
    :config
    (evil-commentary-mode))
  #+END_SRC

  Start a search from visual selection with ~*~ or ~#~ (backward).
  #+BEGIN_SRC emacs-lisp
  (use-package evil-visualstar
    :after evil
    :config
    (global-evil-visualstar-mode t))
  #+END_SRC

  Jump to matching pairs with ~%~.
  #+BEGIN_SRC emacs-lisp
  (use-package evil-matchit
    :defer 2
    :after evil
    :config
    (global-evil-matchit-mode 1))
  #+END_SRC

  Persist highlight from ~evil search~ and ~isearch~
  #+BEGIN_SRC emacs-lisp
  (use-package evil-search-highlight-persist
    :defer 2
    :config
    (global-evil-search-highlight-persist t))
  #+END_SRC

  I prefer to not start in normal mode with some modes.
  #+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    ;; :init
    ;; (setq evil-mode-line-format nil)
    :config

    (evil-mode 1)
    (evil-set-initial-state 'deft-mode 'insert)
    (evil-set-initial-state 'dired-mode 'normal)
    (evil-set-initial-state 'magit-mode 'emacs)
    (evil-set-initial-state 'use-package-statistics 'emacs)
    (evil-set-initial-state 'xref--xref-buffer-mode 'emacs)
    (evil-set-initial-state 'term-mode 'emacs)

    (evil-ex-define-cmd "W" 'save-buffer))
  #+END_SRC

  Add text objects to select, copy things based on indentation level.
  Use it with ~vii~ and ~yii~.
  #+BEGIN_SRC emacs-lisp
  (use-package evil-indent-plus
    :after evil
    :config
    (evil-indent-plus-default-bindings))
  #+END_SRC

* Search
Searching is probably the most important thing in a code editor.
Here is how I search.

** Search in current file/buffer

I have two main way to search in a buffer:

*** Vim way
I use ~evil-search-forward~ (bound to ~/~) and
~evil-search-backward~ (bound to ~?~) as it allows me to do
powerful /vim/ combinations.

For example I do a search, then navigate through the search list
with ~n~ or ~N~. Or do a search then replace matches with ~:
%s//replacement/gc~

*** swiper
I use ~swiper-isearch~ when I am exploring the buffer or when I
want to do some search refinements or complex replacements.

From counsel it is easy to swith to occur with ~C-c C-o~. This
allows me to have a list of matches in a seperate buffer and edit
them using:
- ~C-x C-q~
- make the changes in the occur buffer
- ~C-x C-s~ to save the changes

  #+BEGIN_SRC emacs-lisp
  (use-package ivy
    :diminish ivy-mode
    :bind (("C-s" . swiper-isearch)
           :map my-keys-minor-mode-map
           ("C-c v" . ivy-push-view)
           ("C-c V" . ivy-pop-view))
    :init
    (setq ivy-use-selectable-prompt t)
    ;; enable bookmarks and recent-f
    (setq ivy-use-virtual-buffers t)
    (setq enable-recursive-minibuffers t)
    (setq ivy-initial-inputs-alist nil)
    (setq ivy-re-builders-alist
          '((t . ivy--regex-plus)))
    :config
    (use-package ivy-hydra)
    (ivy-mode 1)
    (defun ivy-switch-buffer-occur ()
      "Occur function for `ivy-switch-buffer' using `ibuffer'."
      (ibuffer nil (buffer-name) (list (cons 'name ivy--old-re))))
    (ivy-set-occur 'ivy-switch-buffer 'ivy-switch-buffer-occur))
    (eval-after-load "ivy"
      '(define-key ivy-minibuffer-map (kbd "C-c SPC") 'ivy-restrict-to-matches))
  #+END_SRC

** Search in visible windows
#+BEGIN_SRC emacs-lisp
(use-package avy
  :bind (:map my-keys-minor-mode-map
         ("C-c ;" . avy-goto-char-timer)))
#+END_SRC
** Search in project

~counsel-rg~ is my main way to search. Invoked with an argument, it
allows you to specify the directory and search options.
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :bind (:map my-keys-minor-mode-map ("C-c f" . counsel-rg)))
#+END_SRC

When I am investigating things, I like to see a preview of the
results as I scroll down the search results. I do it with ~C-o~ then
either ~g~ on the entry I want to preview or ~c~ to automatically
preview results as I move through the result list.

A trick I am learning is to use ~C-'~ to jump directly to a
search results.

*** When I need to narrow down my search to specific files

**** Narrowing on the file-type

Launch ~counsel-rg~ with a prefix and then I can use for example
~-tjs~ as an argument to search only inside javascript files.
~-Tjs~ searches inside files but javascript ones.

**** From Dired
~C-x d~ to launch dired . I mark the files I am interested in with
~m~. Then I can grep those files with ~A~ and do a query replace
with ~Q~.
** Search Emacs documentation

Remplacements for emacs search and completion commands.
I find the UI better.
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :bind (("M-x" . counsel-M-x)
         ("C-x C-m" . counsel-M-x)
         ("C-c C-m" . counsel-M-x)
         ("C-x C-f" . counsel-find-file)
         ("<f1> f" . counsel-describe-function)
         ("<f1> v" . counsel-describe-variable)
         ("<f1> l" . counsel-find-library)
         ("<f2> i" . counsel-info-lookup-symbol)
         ("<f2> u" . counsel-unicode-char)
         :map minibuffer-local-map
         ("C-r" . counsel-minibuffer-history)
         :map my-keys-minor-mode-map
         ("C-c r" . counsel-recentf)
         ("C-c i" . counsel-imenu)
         ("C-c m" . counsel-bookmark))
  :init
  (setq counsel-git-cmd "rg --files")
  (setq counsel-rg-base-command
        "rg --smart-case -M 120 --hidden --no-heading --line-number --color never %s ."))

  :config
(eval-after-load "counsel" '(progn
                              (defun counsel-imenu-categorize-functions (items)
                                "Categorize all the functions of imenu."
                                (let ((fns (cl-remove-if #'listp items :key #'cdr)))
                                  (if fns
                                      (nconc (cl-remove-if #'nlistp items :key #'cdr)
                                             `((":" ,@fns)))
                                    items)))))

#+END_SRC

** Rename

~iedit~ makes it very easy to
Prefix with ~0~ to only match in current function.
Prefix with universal argument to repeat the previous iedit match.
Select region and press ~F6~ again to restrict to region.
~tab~ and ~S-tab~ to navigate between matches. ~M-;~ to clear a match.

Shows only matching lines with ~C-'~
#+BEGIN_SRC emacs-lisp
(use-package iedit
 :bind (:map my-keys-minor-mode-map ("<f6>" . iedit-mode)))
#+END_SRC

Sometimes I like to use the mouse to setup multiple cursors. For
other /multiple-cursors/ usage I prefer to use either
~evil-visual-block-mode~ or ~iedit~.
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :bind (:map my-keys-minor-mode-map
              ("C-S-<mouse-1>" . mc/add-cursor-on-click)
              ("C-c c a" . mc/mark-all-like-this)
              ("C-c c p" . mc/mark-previous-like-this)
              ("C-c c n" . mc/mark-next-like-this)))
#+END_SRC

* VCS
I mainly use git. I prefix all git related keybindings with ~c-c g~.

Don't forget emacs vcs features accessible with the prefix ~C-x v~!

** Resolving conflicts

This is to prevent popup windows when resolving file conflicts.
I prefer to have the ediff take over and restove the windows when
done.
#+BEGIN_SRC emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
(add-hook 'ediff-after-quit-hook-internal 'winner-undo)
(setq ediff-split-window-function 'split-window-vertically)
#+END_SRC

** Working with github

To grab a link I can share with co-workers from the region or file.
#+BEGIN_SRC emacs-lisp
(use-package git-link
  :bind (:map my-keys-minor-mode-map
              ("C-c gl" . git-link)))
#+END_SRC

Otherwise I launch a ~gitsh~ session and I use [[https://github.com/github/hub][hub]] to interact with
github directly

** View History
*** timemachine
Allows to view previous versions of a file. It is not focused on the
diff but on the file itself. Use ~n~ and ~p~ to navigate between
versions.
#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :bind (:map my-keys-minor-mode-map
              ("C-c gt" . git-timemachine-toggle))
  :config
  (defadvice git-timemachine-mode (after git-timemachine-change-to-emacs-state activate compile)
    "when entering git-timemachine mode, change evil normal state to emacs state"
    (if (evil-normal-state-p)
        (evil-emacs-state)
      (evil-normal-state)))

  (ad-activate 'git-timemachine-mode))
#+END_SRC
*** vc-annotate

Bound to ~C-x v g~.
- Use ~l~ to see the commit message
- ~f~ to see what the file looked like at that revision. You can
  then use /git-link/ to grab a link with ~C-c gl~
- ~n~ and ~p~ to navigate between revisions
- ~=~ to see the diff.

  I prefer to use a full-window with vc-annotate
  #+BEGIN_SRC emacs-lisp
  (use-package fullframe
    :config
    (fullframe vc-annotate quit-window))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
  (eval-after-load "vc-annotate"
       '(progn
        (define-key vc-annotate-mode-map "j" 'evil-next-line)
        (define-key vc-annotate-mode-map "k" 'evil-previous-line)))

  (use-package evil
    :config
    (evil-define-key 'normal diff-mode-map (kbd "q") 'quit-window))
  #+END_SRC

** Magit

#+BEGIN_QUOTE
[[https://magit.vc/][Magit]] is an interface to the version control system Git, implemented
as an Emacs package. Magit aspires to be a complete Git porcelain.
While we cannot (yet) claim that Magit wraps and improves upon each
and every Git command, it is complete enough to allow even
experienced Git users to perform almost all of their daily version
control tasks directly from within Emacs. While many fine Git
clients exist, only Magit and Git itself deserve to be called
porcelains.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package magit
  :bind (:map my-keys-minor-mode-map
              ("C-c gs" . magit-status)
              ("C-c gc" . magit-commit)
              ("C-c gp" . magit-push-current)
              ("C-c gf" . magit-file-dispatch))
  :init
  (setq magit-commit-show-diff nil
        magit-revert-buffers 1))
#+END_SRC

When I use magit, I prefer to have it use the full emacs frame
instead of splitting the current buffer.
#+BEGIN_SRC emacs-lisp
(use-package fullframe
  :after magit
  :config
  (fullframe magit-status magit-mode-quit-window))
#+END_SRC

Start in insert mode when committing from vcs
#+BEGIN_SRC emacs-lisp
(use-package evil
  :config
  (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+END_SRC

** gitsh

#+BEGIN_QUOTE
The [[https://github.com/thoughtbot/gitsh][gitsh]] program is an interactive shell for git. From within
gitsh you can issue any git command, even using your local aliases
and configuration
#+END_QUOTE

When I have to do git related things that are painful to do with
magit, I just fire a terminal with /gitsh/ for the current project.
#+BEGIN_SRC emacs-lisp
(defun ab-run-gitsh ()
  "Start gitsh in current git project. Uses st as a terminal."
  (interactive)
  (let ((default-directory (locate-dominating-file (expand-file-name default-directory) ".gitignore")))
    (start-process "gitsh" nil "gnome-terminal" "--geometry=120x70" "--class=scratch-term" "--" "gitsh")))
(define-key my-keys-minor-mode-map (kbd "C-c gg") 'ab-run-gitsh)
#+END_SRC

** Visual enhancements

See in the fringe lines added, changed and removed since last commit.
#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :after magit
  :config
  (add-hook 'prog-mode-hook 'diff-hl-mode)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
#+END_SRC

* Projects
Emacs is not an IDE but I can be pretty close to one.
Here are some tools I use that are IDE oriented.

** Find file in project
*** Examples
#+BEGIN_SRC emacs-lisp :tangle no
;; if the full path of current file is under SUBPROJECT1 or SUBPROJECT2
;; OR if I'm reading my personal issue track document,
(defun my-setup-develop-environment ()
  (interactive)
  (when (ffip-current-full-filename-match-pattern-p "\\(PROJECT_DIR\\|issue-track.org\\)")
    ;; Though PROJECT_DIR is team's project, I care only its sub-directory "subproj1""
    (setq-local ffip-project-root "~/projs/PROJECT_DIR/subproj1")
    ;; well, I'm not interested in concatenated BIG js file or file in dist/
    (setq-local ffip-find-options "-not -size +64k -not -iwholename '*/dist/*'")
    ;; for this project, I'm only interested in certain types of files
    (setq-local ffip-patterns '("*.html" "*.js" "*.css" "*.java" "*.xml" "*.js"))
    ;; maybe you want to search files in `bin' directory?
    (setq-local ffip-prune-patterns (delete "*/bin/*" ffip-prune-patterns))
    ;; exclude `dist/' directory
    (add-to-list 'ffip-prune-patterns "*/dist/*"))
  ;; insert more WHEN statements below this line for other projects
  )

;; most major modes inherit from prog-mode, so below line is enough
(add-hook 'prog-mode-hook 'my-setup-develop-environment)
#+END_SRC

All variables may be overridden on a per-directory basis in your
.dir-locals.el. See (info â(Emacs) Directory Variablesâ) for
details.

You can place .dir-locals.el into your project root directory.

A sample .dir-locals.el,

#+BEGIN_SRC emacs-lisp :tangle no
((nil . ((ffip-project-root . "~/projs/PROJECT_DIR")
         ;; ignore files bigger than 64k and directory "dist/" when searching
         (ffip-find-options . "-not -size +64k -not -iwholename '*/dist/*'")
         ;; only search files with following extensions
         (ffip-patterns . ("*.html" "*.js" "*.css" "*.java" "*.xml" "*.js"))
         (eval . (progn
                   (require 'find-file-in-project)
                   ;; ignore directory ".tox/" when searching
                   (setq ffip-prune-patterns `("*/.tox/*" ,@ffip-prune-patterns))
                   ;; Do NOT ignore directory "bin/" when searching
                   (setq ffip-prune-patterns `(delete "*/bin/*" ,@ffip-prune-patterns))))
         )))
#+END_SRC

*** My configuration

To install fd (rust replacement for find), download it
[[https://github.com/sharkdp/fd/releases][here]] and run ~sudo dpkg -i fd_7.0.0_amd64.deb~. You can then choose
to use `fd` instead of find.
#+BEGIN_SRC emacs-lisp
(use-package find-file-in-project
  :ensure t
  :bind (:map  my-keys-minor-mode-map
               ("C-c t" . find-file-in-project)
               ;; ("C-c t" . counsel-fzf)
               ("C-c T" . find-file-in-project-by-selected)
               :map evil-normal-state-map
               ("gf" . find-file-in-project-at-point))
  :config

  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.png")) ffip-ignore-filenames))
  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.jpg")) ffip-ignore-filenames))
  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.jpeg")) ffip-ignore-filenames))
  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.gif")) ffip-ignore-filenames))
  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.bmp")) ffip-ignore-filenames))
  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.ico")) ffip-ignore-filenames))
  (setq ffip-prefer-ido-mode nil)
  (setq ffip-use-rust-fd nil) ;; find works better than fd. fd with ffip ignores my .emacs.d directory for some reason
  (setq ffip-strip-file-name-regex "\\(\\.mock\\|_test\\|\\.test\\|\\.mockup\\|\\.spec\\)")
  (add-to-list 'ffip-prune-patterns "*/.git/*")
  (add-to-list 'ffip-prune-patterns "*/dist/*")
  (add-to-list 'ffip-prune-patterns "*/.emacs.d/elpa/*")
  (add-to-list 'ffip-prune-patterns "*/.nuxt/*")
  (add-to-list 'ffip-prune-patterns "*/spec/coverage/*")
  (add-to-list 'ffip-prune-patterns "*/public/*")
  (add-to-list 'ffip-prune-patterns "*/.shadow-cljs/*")
  (add-to-list 'ffip-prune-patterns "node_modules/*"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'abo-find-in-project)
(define-key my-keys-minor-mode-map (kbd "C-c s") 'abo-find-file-with-similar-name)
#+END_SRC
** Jump

/dumb-jump/ just do a search through the project to try to guess the
correct jump location for the current symbol. It is not has good as an
IDE code analysis but it works surprisingly well.

I added a small function to make the current line flash just after a jump
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :init
  (setq dumb-jump-selector 'ivy)
  :config
(setq xref-backend-functions (remq 'etags--xref-backend xref-backend-functions))
(add-to-list 'xref-backend-functions #'dumb-jump-xref-activate t)
  (add-hook 'dumb-jump-after-jump-hook
            (defun abo-dumb-jump-pulse-line ()
              (pulse-momentary-highlight-one-line (point)))))
#+END_SRC

** Tags

Tags are generated through a [[file:~/dotfiles/git/.git_template/hooks/post-commit::.git/hooks/create_ctags%20>/dev/null%202>&1%20&][git hook]] with [[https://ctags.io/][Universal ctags]].

To make sure my hooks are used I delete the hooks directory
~./git/config~ and run ~git init .~ again from the concerned project
directory.

My [[file:~/dotfiles/git/.git_template][templates]] are used thanks to the [[~GIT_TEMPLATE_DIR][~GIT_TEMPLATE_DIR~]] environment variable.
#+BEGIN_SRC shell :results output
   env | grep GIT_TEMPLATE_DIR
#+END_SRC

#+RESULTS:
: GIT_TEMPLATE_DIR=/home/auray/.git_template

I install Universal ctags with
#+BEGIN_SRC shell :results output
   brew install --HEAD universal-ctags/universal-ctags/universal-ctags
#+END_SRC

To verify you have the proper version of universal ctags run
#+BEGIN_SRC shell :results output
   ctags --version | grep -q "Universal Ctags" >/dev/null && echo "Universal ctags is installed" || echo "Missing Universal ctags"
#+END_SRC

#+RESULTS:
: Universal ctags is installed

** Navigation tree
#+begin_src emacs-lisp
 (setq speedbar-directory-unshown-regexp "^$")
 (define-key my-keys-minor-mode-map (kbd "C-c b") 'speedbar-get-focus)
#+end_src

* Completion
** Hippie expand
Bound to ~s-/~, it provides a simple on demand completion mechanism.
You can customize its behaviour by choosing different expand functions.

The description of all the hippie expand functions is inside
[[https://github.com/emacs-mirror/emacs/blob/master/lisp/hippie-exp.el#L63][~hippie-exp.el~]] (location can vary on your system)
#+BEGIN_SRC emacs-lisp
(setq hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-from-kill try-expand-all-abbrevs try-expand-list))
(require 'mode-local)
(setq-mode-local elisp-mode hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-from-kill try-expand-list try-complete-lisp-symbol-partially try-complete-lisp-symbol))
(setq-mode-local elisp-mode hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-from-kill try-expand-all-abbrevs try-complete-lisp-symbol-partially try-complete-lisp-symbol))
(define-key evil-insert-state-map (kbd "s-/") 'hippie-expand)
(define-key evil-insert-state-map (kbd "M-/") 'hippie-expand)
#+END_SRC

** Auto-Completion

company shows a popup where you can select completions with a number
or with ~enter~. You can also invoke the popup manually with ~C-x
C-o~
#+BEGIN_SRC emacs-lisp
(use-package company
  :defer 2
  :diminish company-mode
  :config
  (setq company-idle-delay 0.2
        company-tooltip-limit 10
        company-tooltip-align-annotations t
        company-require-match 'never
        company-global-modes '(not eshell-mode comint-mode erc-mode message-mode help-mode gud-mode)
        company-frontends '(company-pseudo-tooltip-frontend company-echo-metadata-frontend)
        company-backends '((company-files company-dabbrev-code company-capf company-yasnippet))
        company-transformers '(company-sort-by-occurrence))
  (global-company-mode +1)

  (add-hook 'after-init-hook 'global-company-mode)
  (setq company-dabbrev-downcase nil)
  (setq company-show-numbers t)
  (define-key evil-insert-state-map (kbd "C-x C-o") 'company-complete)

  (use-package company-statistics
    :after company
    :config
    (setq company-statistics-file "~/.emacs.d/company-stats-cache.el")
    (company-statistics-mode +1))

  (autoload 'company-capf "company-capf")
  (autoload 'company-yasnippet "company-yasnippet")
  (autoload 'company-elisp "company-elisp")
  (autoload 'company-files "company-files")
  (let ((map company-active-map))
    (mapc
     (lambda (x)
       (define-key map (format "%d" x) 'ora-company-number))
     (number-sequence 0 9))
    (define-key map " " (lambda ()
                          (interactive)
                          (company-abort)
                          (self-insert-command 1)))
    (define-key map (kbd "<return>") nil))

  (defun ora-company-number ()
    "Forward to `company-complete-number'.

     Unless the number is potentially part of the candidate.
     In that case, insert the number."
    (interactive)
    (let* ((k (this-command-keys))
           (re (concat "^" company-prefix k)))
      (if (cl-find-if (lambda (s) (string-match re s))
                      company-candidates)
          (self-insert-command 1)
        (company-complete-number (string-to-number k))))))
#+END_SRC

** Snippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :defer 3
  :commands yas-expand-snippet
  :bind (:map my-keys-minor-mode-map
              ("C-c y" . yas-insert-snippet))
  :diminish yas-minor-mode
  :init
  (setq yas-snippet-dirs
        '("~/.emacs.d/snippets"))
  :config
  (yas-global-mode 1)
  (add-hook 'term-mode-hook (lambda()
                              (yas-minor-mode -1))))
#+END_SRC

This allow me to automatically expand [[https://github.com/aurelienbottazini/dotfiles/blob/master/emacs/.emacs.d/templates/][templates]] into new files using
the yasnippet format. The filenames for the template are regexes.
#+BEGIN_SRC emacs-lisp :tangle no
(use-package yatemplate
  :config
  (add-hook 'find-file-hook 'auto-insert)
  (yatemplate-fill-alist))
#+END_SRC

* Files and directories
** Dired
#+BEGIN_SRC emacs-lisp
(setq ls-lisp-use-insert-directory-program t) ;same ls-lisp for Dired regardless of the platform
(setq dired-listing-switches "-alh")
;; on mac there is some weird prefixing going on for GNU Tools like ls.
;; I favor GNU ls over MacOSX default ls
(when (string-equal system-type "darwin")
  (setq insert-directory-program "gls"))

(require 'dired )
(defun my-dired-mode-setup ()
  "to be run as hook for `dired-mode'."
  (dired-hide-details-mode 1))
(add-hook 'dired-mode-hook 'my-dired-mode-setup)

(put 'dired-find-alternate-file 'disabled nil)
(setq dired-dwim-target t)
(add-hook 'dired-load-hook
          (lambda ()
            (load "dired-x")
            ;; Set dired-x global variables here.  For example:
            ;; (setq dired-guess-shell-gnutar "gtar")
            ;; (setq dired-x-hands-off-my-keys nil)
            (setq dired-recursive-copies (quote always)) ; âalwaysâ means no asking
            (setq dired-recursive-deletes (quote top)) ; âtopâ means ask once
            ))

(eval-after-load "dired"
  '(progn
     (define-key dired-mode-map "-" 'dired-up-directory)
     (define-key dired-mode-map (kbd "/") 'evil-search-forward)
     (define-key dired-mode-map (kbd "j") 'dired-next-line)
     (define-key dired-mode-map (kbd "k") 'dired-previous-line)
     (define-key dired-mode-map (kbd "[b") 'previous-buffer)
     (define-key dired-mode-map (kbd "]b") 'next-buffer)
     (define-key dired-mode-map (kbd "C-u") 'evil-scroll-page-up)
     (define-key dired-mode-map (kbd "C-d") 'evil-scroll-page-down)
     (evil-define-key 'normal dired-mode-map
       "gg" 'evil-goto-first-line
       "^" '(lambda () (interactive) (find-alternate-file "..")))))

(define-key package-menu-mode-map (kbd "/") 'evil-search-forward)

(use-package dired-rsync
:bind (:map dired-mode-map ("p" . dired-rsync)))
#+END_SRC

** Counsel
I redefine the standard ~C-x C-f~ to use counsel. It allows me to do
pretty cool stuff with it [[https://oremacs.com/2017/11/18/dired-occur/][thanks to ivy-occur and dired]].

#+BEGIN_QUOTE
To delete all *.elc files in the current folder do:

~C-x C-f elc$ C-c C-o tDy.~

To copy all Org files in a Git project to some directory do:

~M-x counsel-git org$ C-c C-o tC.~

To get a list of videos to watch do:

~M-x counsel-fzf mp4$ C-c C-o.~
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :bind (("C-x C-f" . counsel-find-file)))
#+END_SRC

* Testing

#+begin_src emacs-lisp :results silent
(setq vc-follow-symlinks t)
(put 'magit-edit-line-commit 'disabled nil)
(put 'narrow-to-region 'disabled nil)

;; I don't want to keep the current tags table when there's another one in the directory i am visiting.
;; Let's automatically switch to the new one without asking
(setq tags-add-tables nil)
#+end_src

#+begin_src emacs-lisp :results silent
(require 'wat-mode)
#+end_src

#+BEGIN_SRC emacs-lisp
(use-package rust-mode
 :bind (:map rust-mode-map
        ("C-c C-c" . rust-run)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package engine-mode
  :bind (:map my-keys-minor-mode-map
         ("C-c d c" . engine/search-caniuse)
         ("C-c d m" . engine/search-mdn)
         ("C-c d ra" . engine/search-rails)
         ("C-c d rr" . engine/search-ruby))
  :config
  (defengine ruby "https://apidock.com/ruby/search?query=%s")
  (defengine rails "https://api.rubyonrails.org/?q=%s")
  (defengine mdn "https://developer.mozilla.org/en-US/search?q=%s")
  (defengine caniuse "https://caniuse.com/#search=%s")
)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-key my-keys-minor-mode-map "\C-c u" 'universal-argument)
(define-key my-keys-minor-mode-map "\C-u" 'evil-scroll-up)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package restclient
 :demand t
 :config
 (add-to-list 'auto-mode-alist '("\\.http\\'" . restclient-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
 (use-package peep-dired
  :defer t ; don't access `dired-mode-map' until `peep-dired' is loaded
  :bind (:map dired-mode-map
              ("P" . peep-dired)))
#+END_SRC

#+begin_src emacs-lisp :results silent
(use-package general
 :config
(general-create-definer my-leader-def
  ;; :prefix my-leader
  :prefix "SPC")

(my-leader-def
  :states 'normal
  :keymaps 'override
  "SPC" 'counsel-rg
  "p" 'find-file-in-project
  "b" 'counsel-buffer-or-recentf
  "m" 'counsel-bookmark))
#+end_src

Code folding
#+BEGIN_SRC emacs-lisp :results silent
(use-package origami
 :config
  (global-origami-mode))
#+END_SRC

* Local variables

# Local Variables:
# eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
# End:
