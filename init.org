#+title: Aurélien Bottazini's Emacs configuration
#+OPTIONS: toc:4 h:4
#+PROPERTY: header-args :results silent :tangle yes

* Advanced patterns
** filter with rg
With counsel-rg you can pass arguments
#+begin_src
 foo -- -g!*.el
#+end_src
** filter with ivy
You can negate filter with ivy too
#+begin_src
foo ! .el$
#+end_src
** grep with dired
mark files with m and grep with A and Q to grep replace
** ivy-occur
C-o from an ivy completion and C-x C-q to modify results
** replace in buffer
M-%

* Faster startup
Adjusts garbage collector for faster startup.
#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
(defvar last-file-name-handler-alist file-name-handler-alist)
(setq gc-cons-threshold 100000000
      gc-cons-percentage 0.6
      file-name-handler-alist nil)


(add-hook 'emacs-startup-hook (lambda ()
                                (setq gc-cons-threshold 16777216
                                      gc-cons-percentage 0.1
                                      file-name-handler-alist last-file-name-handler-alist)))
#+end_src

* Debug Emacs

If Emacs complains about a mismatched paren while trying to start
you can use ~check-parens~ to find the mismatched parenthesis.
#+begin_src emacs-lisp :tangle no
(check-parens)
#+end_src

Emacs tends to swallow errors.
If something is not working correctly there is a good chance you will
discover what is wrong by turning on ~toggle-debug-on-error~
#+begin_src emacs-lisp :tangle no
(toggle-debug-on-error)
#+end_src

If a command is slow you can investigate with
#+begin_src emacs-lisp :tangle no
(profiler-start)
;; run your slow command
(profiler-report)
#+end_src

* Package library initialization

Silence deprecated cl warnings
#+begin_src emacs-lisp
(setq byte-compile-warnings '(cl-functions))
#+end_src

#+BEGIN_SRC emacs-lisp
(setq package-archives
      '(("melpa"       . "https://melpa.org/packages/")
        ("org"         . "https://orgmode.org/elpa/")
        ("gnu"         . "http://elpa.gnu.org/packages/")))

(setq package-user-dir (concat user-emacs-directory "elpa"))

;; this tells package.el not to add those pesky customized variable settings at
;; the end of your init.el
(setq package--init-file-ensured t)

(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))

(defun require-package (package &optional min-version)
  "Ask elpa to install given PACKAGE. You can specify a MIN-VERSION for your PACKAGE."
  (unless (package-installed-p package min-version)
    (package-install package)))

(require-package 'use-package)
(require 'use-package)

(setq use-package-compute-statistics t) ;(use-package-report) to show  which package is slow to start.
(setq use-package-always-ensure t) ; Install package if it is missing
#+END_SRC

You can get the time it took for emacs to start with.
#+BEGIN_SRC emacs-lisp :tangle no
(emacs-init-time)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(use-package diminish
  :config
  (eval-after-load "undo-tree"
    '(diminish 'undo-tree-mode))
  (eval-after-load "subword"
    '(diminish 'subword-mode))
  (diminish 'auto-fill-function)
  (diminish 'org-indent-mode)
  (diminish 'visual-line-mode)
  (diminish 'org-indent-mode)
  (diminish 'eldoc-mode))
#+END_SRC

It is important to load custom settings early. Those are the ones
managed by Emacs through customization menus. They can impact the
loading of other packages.
#+BEGIN_SRC emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(load custom-file)
#+END_SRC

As I work on different computers, I need slightly different
settings. Instead of embedding machine specific code through
conditionals, I use a file to load machine specifics global
variables that are used in other parts of this configuration. I have
a small convention for the names. I surround them with double stars
and the name starts with local. Ex: ~(setq **local-my-variable**
"foo/bar")~.
#+BEGIN_SRC emacs-lisp
(if (file-exists-p "~/.emacs.d/.emacs-local")
    (load "~/.emacs.d/.emacs-local"))
#+END_SRC

I keep elisp I write, or elisp not available on melpa inside the
site-lisp directory. The files in that directory are automatically
added to the Emacs load-path.
#+BEGIN_SRC emacs-lisp
(let ((default-directory  "~/.emacs.d/site-lisp/"))
  (normal-top-level-add-to-load-path '("."))
  (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'org)
#+END_SRC

* Local variables
Local variables are useful to customize your settings for different
projects/directories. The built in ~make-local-variable~ is
convenient in helping you create those variables.

It is annoying when I edit those local variables that they are not
picked up automatically for open buffers. Those two functions help me
with the reloading of those locals.
#+BEGIN_SRC emacs-lisp
(defun my-reload-dir-locals-for-current-buffer ()
  "Reloads dir locals for the current buffer."
  (interactive)
  (let ((enable-local-variables :all))
    (hack-dir-local-variables-non-file-buffer)))

(defun my-reload-dir-locals-for-all-buffer-in-this-directory ()
  "For every buffer with the same `default-directory` as the current buffer's, reload dir-locals."
  (interactive)
  (let ((dirdefault-directory))
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (when (equal default-directory dir))
        (my-reload-dir-locals-for-current-buffer)))))
#+END_SRC

* Better Defaults
#+begin_src emacs-lisp
(setq initial-major-mode 'fundamental-mode)
(setq initial-scratch-message nil)
#+end_src

#+begin_src emacs-lisp
(setq vc-follow-symlinks t)
(put 'magit-edit-line-commit 'disabled nil)
(put 'narrow-to-region 'disabled nil)

(setq tags-add-tables 'nil) ; always start a new TAGS table don't ask the user
#+end_src

I like setting the path manually as other solutions like ~exec-path-from-shell~
can slow down Emacs startup if the shells scripts do too many things.

`exec-path` is used by Emacs to find executables.
`PATH` is used by Emacs when you are running a shell in Emacs.
It make things easier when the two match.
#+BEGIN_SRC emacs-lisp
(setenv "JAVA_HOME" "/Library/Java/JavaVirtualMachines/adoptopenjdk-12.0.2.jdk/Contents/Home")
(setenv "OBJC_DISABLE_INITIALIZE_FORK_SAFETY" "YES")

(let* ((home-folder (getenv "HOME"))
       (my-paths `("/opt/homebrew/bin"
                   "/Applications/Postgres.app/Contents/Versions/latest/bin"
                   ,(concat home-folder "/.asdf/shims/")
                   ,(concat home-folder "/.config/yarn/global/node_modules/.bin/")
                   ,(concat home-folder "/.local/share/n/bin")
                   ,(concat home-folder "/work/dox-compose/bin/")
                   ,(concat home-folder "/dotfiles/bin/")
                   ,(concat home-folder "/.fzf/bin")
                   ,(concat home-folder "/.local/bin")
                   ,(concat home-folder "/.local/share/npm/bin/")
                   ,(concat home-folder "/bin")
                   "/snap/bin"
                   "/usr/local/bin"
                   "/bin/"
                   "/usr/bin/"
                   "/usr/local/sbin/"
                   "/opt/homebrew/opt/openjdk/bin/"
                   "/usr/bin/"
                   ,(concat home-folder "/.cargo/bin/"))) ;; /usr/bin/ is repeated because eshell does not consider last entry. Bug?
       )

  (setenv "PATH" (concat (mapconcat 'identity my-paths ":" ) ":"))
  (setq eshell-path-env (concat (mapconcat 'identity my-paths ":" ) ":"))
  (setq exec-path my-paths))
#+END_SRC

Emacs can be really fast with large files too. The trick is to
stick to fundamental mode and disable expensive minor modes.
#+BEGIN_SRC emacs-lisp
(defun check-large-file-hook ()
  "If a file is over a given size, turn off minor modes."
  (when (and (> (buffer-size) (* 1024 100)) ;; 100K
             (not (string-equal "jpg" (file-name-extension (buffer-file-name))))
        )
    (fundamental-mode)
    (font-lock-mode -1)
    (setq buffer-read-only t)
    (buffer-disable-undo)))
(add-hook 'find-file-hooks 'check-large-file-hook)


;; only support left to right languages.
;; this makes long lines in files not a problem anymore.
(setq-default bidi-paragraph-direction 'left-to-right)
(setq bidi-inhibit-bpa t)

(global-so-long-mode 1) ;; helps when visiting files with long lines.
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq help-window-select t ; if an help window appears, give it focus
      inhibit-startup-message t
      default-indicate-empty-lines nil ; show end of buffer on left fringe
      )

(make-variable-buffer-local 'compile-command) ; makes the compile command buffer specific.
(defalias 'yes-or-no-p 'y-or-n-p) ; instead of typing yes or no, type y or n
(setq ring-bell-function 'ignore) ; please don't startle me with a bell!

(setq backup-by-copying t      ; don't clobber symlinks
      backup-directory-alist
      '((".*" . "~/.local/share/emacs-saves"))    ; don't litter my filesystem with saves
      delete-old-versions t
      kept-new-versions 6
      kept-old-versions 2
      delete-by-moving-to-trash t
      auto-save-default t ;files starting with # are generated by autosave
      auto-save-timeout 60 ; number of seconds before auto-saving
      auto-save-interval 200 ; number of keystrokes before auto-saves
      version-control t ; use versioned backups
      create-lockfiles nil
      auto-save-file-name-transforms `((".*" ,"~/.local/share/emacs-saves" t))
      )

(setq global-auto-revert-non-file-buffers t) ; also auto-revert dired buffers and other special buffers

;; if file has no change, just load any changes
;; coming from an external process
(global-auto-revert-mode 1)

;; replace selected text when typing.
(pending-delete-mode 1)

(prefer-coding-system 'utf-8)
(modify-coding-system-alist 'process "\\*compilation\\*\\'"   'utf-8)

(setq-default truncate-lines t)
#+END_SRC

Sentences end with one space after point. The default two space is
an historical setting. This makes Emacs sentence based commands follow
the modern standard.
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

I want error highlights and error bindings in shell modes too.
#+BEGIN_SRC emacs-lisp
(add-hook 'shell-mode-hook 'compilation-shell-minor-mode)
#+END_SRC

*** tabs and white-space
By default I disable tabs. I use ~whitespace-mode~ in programming
buffers because sometimes when copy pasting code from external
sources those external sources have tabs. I want to see those tabs
to remove them.

I don't use the ~global-whitespace-mode~ as some emacs mode like
~magit~ use tabs.

You can remove all tabs from your buffer with ~untabify~

#+BEGIN_SRC emacs-lisp
(setq-default
 indent-tabs-mode nil    ; no tabs
 c-basic-offset 2)
#+END_SRC

Makes trailing white space and tabs visible.
#+BEGIN_SRC emacs-lisp
(setq-default whitespace-style '(face trailing))
#+END_SRC

Clean white space on save.
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
(add-hook 'prog-mode-hook 'whitespace-mode)
(eval-after-load "whitespace"
  '(diminish 'whitespace-mode))
#+END_SRC

*** Recent files
#+BEGIN_SRC emacs-lisp
(recentf-mode 1)
(setq recentf-max-menu-items 200)
(setq recentf-max-saved-items 200)
#+END_SRC

* Movement
Move between buffers with C-h C-j C-k C-l. My Tmux bindings are made
to [[https://github.com/aurelienbottazini/dotfiles/blob/6cb8e100568cffb788f0ecd8488e4a4fd50349cd/tmux/.config/tmux/tmux.conf#L31-L35][make it work seamlessly]] with Emacs.
#+begin_src emacs-lisp :tangle yes
(defun auray/tmux-active-session ()
  (interactive)
  ;; (substring-no-properties (shell-command-to-string "tmux ls | grep \\\(attached\\\) | cut -d':' -f1") 0 -1))
 (substring-no-properties (shell-command-to-string "tmux list-clients | grep 'attached,focused,' | cut -d' ' -f2") 0 -1))

(defun auray/tmux-select-pane (direction)
  (shell-command (concat  "tmux select-pane -t " (auray/tmux-active-session) " -" direction)))

(defun auray/tmux-move (direction)
  (condition-case nil
      (cond
       ((string= "R" direction) (windmove-right))
       ((string= "L" direction) (windmove-left))
       ((string= "U" direction) (windmove-up))
       ((string= "D" direction) (windmove-down)))
    (error (unless window-system (auray/tmux-select-pane direction)))))

(defun tmux-move-right ()
  (interactive)
  (auray/tmux-move "R"))

(defun tmux-move-left ()
  (interactive)
  (auray/tmux-move "L"))

(defun tmux-move-up ()
  (interactive)
  (auray/tmux-move "U"))

(defun tmux-move-down ()
  (interactive)
  (auray/tmux-move "D"))

  #+END_SRC
* Colors

#+begin_src emacs-lisp :tangle no
(use-package solarized-theme
  :config
  (load-theme 'solarized-dark))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package gruvbox-theme
  :config
  (load-theme 'gruvbox-dark-medium)
  )
#+end_src

Zenburn is one of the most complete theme out there. It also works
well on the terminal.
https://en.wikipedia.org/wiki/Wikipedia:Zenburn.
#+begin_src emacs-lisp :tangle no
;; (when (display-graphic-p)
(use-package zenburn-theme
  :custom-face
  (cider-debug-code-overlay-face ((t (:background "grey80" :foreground "black"))))
  (font-lock-comment-face ((t (:foreground "#7F9F7F" :slant italic))))
  (hi-aquamarine ((t (:background "aquamarine" :foreground "black"))))
  (hi-salmon ((t (:background "light salmon" :foreground "black"))))
  (hlt-property-highlight ((t (:background "Wheat" :foreground "black"))))
  (hlt-regexp-level-1 ((t (:background "#FA6CC847FFFF" :foreground "black"))))
  (hlt-regexp-level-2 ((t (:background "#C847FFFFE423" :foreground "black"))))
  (hlt-regexp-level-3 ((t (:background "#C847D8FEFFFF" :foreground "black"))))
  (hlt-regexp-level-4 ((t (:background "#EF47FFFFC847" :foreground "black"))))
  (hlt-regexp-level-5 ((t (:background "#FCFCE1E1FFFF" :foreground "black"))))
  (hlt-regexp-level-6 ((t (:background "#E1E1FFFFF0F0" :foreground "black"))))
  (hlt-regexp-level-7 ((t (:background "#E1E1EAEAFFFF" :foreground "black"))))
  (hlt-regexp-level-8 ((t (:background "#F6F5FFFFE1E1" :foreground "black"))))
  (lsp-modeline-code-actions-face ((t (:inherit warning))))
  (lsp-ui-doc-background ((t (:background "#2b2b2b"))))
  (minibuffer-prompt ((t (:foreground "#F0DFAF" :height 1.0))))
  (mode-line ((t (:background "#4c7073" :foreground "#dcdccc" :box (:line-width (2 . 2) :color "#4c7073") :height 1.0))))
  (mode-line ((t (:background "#4c7073" :foreground "#dcdccc" :box (:line-width (2 . 2) :color "#4c7073") :height 1.1))))
  (mode-line-buffer-id ((t (:foreground "#f0dfaf" :slant italic :weight bold))))
  (mode-line-inactive ((t (:background "#383838" :foreground "#5F7F5F" :box (:line-width (2 . 2) :color "#383838" :style flat-button) :height 1.1))))
  (org-block ((t (:extend t :background "#333333"))))
  (org-document-info-keyword ((t (:inherit shadow :height 1.3))))
  (org-document-title ((t (:inherit default :foreground "#8CD0D3" :weight bold :height 1.3))))
  (org-drawer ((t (:foreground "#f0dfaf"))))
  (org-level-1 ((t (:inherit outline-1 :extend nil :height 1.3))))
  (org-level-2 ((t (:inherit outline-2 :extend nil :height 1.1))))
  (org-level-3 ((t (:inherit default :extend nil :foreground "#7CB8BB" :slant italic :height 1.1))))
  (org-meta-line ((t (:inherit font-lock-comment-face :height 1.1))))
  (region ((t (:extend t :background "#adcff1" :foreground "black"))))
  (tab-bar ((t (:inherit nil :background "#88b090" :foreground "#2e3330" :slant italic :height 1.1))))
  (tab-bar-tab ((t (:inherit tab-bar :background "#ccdc90" :foreground "#3f3f3f" :box (:line-width (3 . 3) :style pressed-button) :weight bold))))
  (tab-bar-tab-group-current ((t (:inherit tab-bar-tab :background "#ccdc90"))))
  (tab-bar-tab-inactive ((t (:inherit tab-bar-tab :background "#88b090" :foreground "#3f3f3f" :box (:line-width (3 . 3) :style released-button) :slant normal))))
  (tab-line ((t (:inherit variable-pitch :background "#2c302d" :foreground "#dcdccc" :height 0.9))))
  (tab-line-highlight ((t (:background "grey85" :foreground "black" :box (:line-width (1 . 1) :style released-button)))))
  (tab-line-tab ((t (:inherit tab-line :box (:line-width (1 . 1) :style released-button)))))
  (tab-line-tab-current ((t (:inherit tab-line-tab :background "#262626" :foreground "#dcdccc"))))
  (tab-line-tab-inactive ((t (:inherit tab-line-tab))))
  (tab-line-tab-modified ((t (:foreground "#e89393"))))
  (web-mode-html-tag-bracket-face ((t (:foreground "#8f8f8f"))))
  (highlight ((t (:background "#f0dfaf" :foreground "black"))))
  :config
  (setq auray/default-color '("#2b2b2b" "#8fb28f" . "#f0dfaf"))
  (load-theme 'zenburn t)
  )
;; )
#+end_src

* Utility functions

#+BEGIN_SRC emacs-lisp
(defun sudo ()
  "Use TRAMP to `sudo' the file for current buffer."
  (interactive)
  (when buffer-file-name
    (find-alternate-file
     (concat "/sudo:root@localhost:"
             buffer-file-name))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun enable-minor-mode (my-pair)
  "Enable minor mode if filename match the regexp. MY-PAIR is a
cons cell (regexp . minor-mode)."
  (if (buffer-file-name)
      (if (string-match (car my-pair) buffer-file-name)
          (funcall (cdr my-pair)))))

(defun filepath-with-line-number-for-current-buffer ()
  "Return a string with Buffer-file-name:line-number.
             Make it easier to prepare commands for tools like rspec"
  (interactive)
  (concat (buffer-file-name) ":" (number-to-string (line-number-at-pos))))

(defun auray/today ()
  "Today's date as a string."
  (format-time-string "%Y-%m-%d"))

(defun auray/add-date-to-filename ()
  "Add current date in front of filename for current buffer. This is useful with some Blog tools like Jekyll to publish new articles."
  (interactive)
  (let* ((date (abott/today))
         (buffer-file (buffer-file-name))
         (new-file-name (concat (file-name-directory buffer-file)
                                date
                                "-"
                                (file-name-nondirectory buffer-file)))
         )
    (save-buffer)
    (rename-file buffer-file new-file-name)
    (set-visited-file-name new-file-name)
    (save-buffer)))

(defun auray/insert-date ()
  "Insert today's date in current buffer"
  (interactive)
  (insert (abott/today)))

(defun auray/toggle-html-export-on-save ()
  "Enable or disable HTML export when saving current org buffer."
  (interactive)
  (when (not (eq major-mode 'org-mode))
    (error "Not an org-mode file!"))
  (if (memq 'org-html-export-to-html after-save-hook)
      (progn (remove-hook 'after-save-hook 'org-html-export-to-html t)
             (message "Disabled org html export on save"))
    (add-hook 'after-save-hook 'org-publish-current-file nil t)
    (set-buffer-modified-p t)
    (message "Enabled org html export on save")))

(defun auray/change-line-endings-to-unix ()
  (let ((coding-str (symbol-name buffer-file-coding-system)))
    (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
      (set-buffer-file-coding-system 'unix))))
#+END_SRC

* GUI

Enable ligatures on mac
#+begin_src emacs-lisp
(if (fboundp 'mac-auto-operator-composition-mode)
    (mac-auto-operator-composition-mode t))
#+end_src

#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
(column-number-mode) ; column number in the mode line

(electric-indent-mode t)

(electric-pair-mode t)
(setq electric-pair-inhibit-predicate
      (lambda (c)
        (or (minibufferp)
            (eq major-mode 'org-mode)
            (not (or
                  (char-equal c ?\s)
                  (char-equal c ?\t)
                  (eolp))))))

(setq frame-title-format "emacs")

;; makes fringe big enough with HDPI
(when (boundp 'fringe-mode)
  (fringe-mode 20))
#+END_SRC

#+begin_src emacs-lisp
(setq blink-matching-paren 'jump-offscreen)
(show-paren-mode 1)

#+end_src

** Text size

Emacs makes it hard to select font with weight of Regular or Book.
The trick is to just install the font weight you want and omit the medium and
light weights. Medium and Light conflict with the Regular and Book versions

** Code Folding
=set-selective-display=

* Regex

~C-c C-w~ to copy regex
~C-c C-q~ to quit re-builder and to remove highlights
#+BEGIN_SRC emacs-lisp
(require 're-builder)
(setq reb-re-syntax 'string)
#+END_SRC
* Org

#+begin_src emacs-lisp
(setq org-refile-targets '((nil :maxlevel . 3)
                           (org-agenda-files :maxlevel . 3)))
(advice-add 'org-refile :after
            (lambda (&rest _)
              (org-save-all-org-buffers)))
#+end_src

* Windows
Splitting can be done with ~C-x 2~ and ~C-x 3~  or with
~C-w v~ and ~C-w s~ to split vertically and horizontally.
* Programming languages

Auto-fill comments in prog modes
#+BEGIN_SRC emacs-lisp
(defun my-prog-mode-auto-fill-hook ()
  (setq fill-column 100)
  (set (make-local-variable 'comment-auto-fill-only-comments) t)
  (auto-fill-mode t))
(add-hook 'prog-mode-hook 'my-prog-mode-auto-fill-hook)
#+END_SRC

** Clojure
#+BEGIN_SRC emacs-lisp
;; First install the package:
(use-package clojure-mode
  :mode "\\.clj\\'"
  :config
  (add-hook 'clojure-mode-hook #'subword-mode)

  ;; (use-package rainbow-blocks)
  ;; (add-hook 'clojure-mode-hook #'rainbow-blocks-mode)
  )


(use-package cider
  :after clojure-mode
  :config

  (define-key cider-mode-map (kbd "C-c C-c") 'cider-eval-list-at-point)
  (add-hook 'clojure-mode-hook (lambda ()
                                 (add-hook 'before-save-hook 'cider-format-buffer t t)
        ))

  (add-hook 'edn-mode-hook (lambda ()
                                 (add-hook 'before-save-hook 'cider-format-edn-buffer t t)
        ))
  (setq cider-repl-display-help-banner nil))
#+END_SRC
** Ruby
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :mode "\\.ya?ml\\'")

(use-package ruby-ts-mode
  :mode "\\.rake\\'"
  :mode "Rakefile\\'"
  :mode "\\.gemspec\\'"
  :mode "\\.ru\\'"
  :mode "Gemfile\\'"
  :mode "Guardfile\\'"
  :mode "Capfile\\'"
  :mode "\\.cap\\'"
  :mode "\\.thor\\'"
  :mode "\\.rabl\\'"
  :mode "Thorfile\\'"
  :mode "Vagrantfile\\'"
  :mode "\\.jbuilder\\'"
  :mode "Podfile\\'"
  :mode "\\.podspec\\'"
  :mode "Puppetfile\\'"
  :mode "Berksfile\\'"
  :mode "Appraisals\\'"
  :mode "\\.rb$"
  :mode "ruby"
  :config
  (define-key ruby-ts-mode-map (kbd "C-c C-c") 'xmp)
  (add-hook 'ruby-ts-mode-hook (defun auray-ruby-ts-mode-hook ()
             (modify-syntax-entry ?_ "w")       ; now '_' is not considered a word-delimiter
             ))
  )

(use-package robe
  :after evil
  :diminish robe-mode
  :config
  (add-hook 'ruby-mode-hook 'robe-mode)
  (add-hook 'ruby-ts-mode-hook 'robe-mode)
  (add-hook 'ruby-mode-hook 'flycheck-mode)
  (add-hook 'ruby-ts-mode-hook 'flycheck-mode)
  (eval-after-load 'company
  '(push 'company-robe company-backends))
  (evil-define-key 'normal ruby-ts-mode-map (kbd "gd") 'robe-jump)
  )

(use-package ruby-mode
  :config
  ;; (add-hook 'ruby-mode-hook 'subword-mode)


  (define-key ruby-mode-map (kbd "C-c C-c") 'xmp)
  (define-key rspec-mode-map (kbd "C-c r") 'rspec-rerun)
  (define-key ruby-mode-map (kbd "C-c r") 'rspec-rerun)
  (define-key ruby-ts-mode-map (kbd "C-c r") 'rspec-rerun)
  (use-package ruby-interpolation
    :diminish ruby-interpolation-mode)
  (use-package ruby-end
    :diminish ruby-end-mode
    )
  (use-package rspec-mode
    :config
    (add-hook 'after-init-hook 'inf-ruby-switch-setup) ;When you've hit the breakpoint, hit C-x C-q to enable inf-ruby))
#+END_SRC

I learned about this on [[http://www.virtuouscode.com/2013/06/24/rubytapas-freebie-xmpfilter/][Ruby Tapas.]] Hit ~M-;~ twice adds a special
comment for xmpfilter. Running ~xmp~ will evaluate the line and put
the result after the comment. By default it does not work with Ruby
enhanced mode so I made a fix for that.
#+BEGIN_SRC emacs-lisp
(require 'rcodetools)
(defadvice comment-dwim (around rct-hack activate)
  "If comment-dwim is successively called, add => mark."
  (if (and (or (eq major-mode 'enh-ruby-mode)
               (eq major-mode 'ruby-mode)
               (eq major-mode 'ruby-ts-mode)
               )
           (eq last-command 'comment-dwim))
      (progn
        (if (eq major-mode 'enh-ruby-mode)
            (end-of-line))
        (insert "=>"))
    ad-do-it))
#+END_SRC
** Go

#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :mode "\\.go\\'")
#+END_SRC

** HTML

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode "\\.html\\'"
  :mode "\\.gohtml\\'"
  :mode "\\.erb\\'"
  :config
  (setq web-mode-enable-auto-closing t)
  (define-key web-mode-map (kbd "C-c C-c e") 'emmet-expand-line)
  )

(use-package emmet-mode
  :hook (css-mode sgml-mode web-mode)
  :diminish emmet-mode
  :config
  (add-hook 'css-mode-hook
            (lambda ()
              (emmet-mode)
              (define-key css-mode-map (kbd "C-c C-c e") 'emmet-expand-line)
              (setq emmet-expand-jsx-className? nil)))

  (add-hook 'sgml-mode-hook
            (lambda ()
              (emmet-mode)
              (setq emmet-expand-jsx-className? nil))))
#+END_SRC

** CSS
#+BEGIN_SRC emacs-lisp
(use-package scss-mode :mode "\\.scss\\'")
(use-package sass-mode :mode "\\.sass\\'")
(use-package less-css-mode :mode "\\.less\\'")
#+END_SRC
** JavaScript
Node compilation errors messages are not understood by Emacs by
default. All that's needed to make it work is to add a new regex
describing what are the components of the messages.
After running the compile command, you can navigate through the
errors with ~next-error~ and ~previous-error~

Hooks put on js-mode are also run on js2-mode
#+BEGIN_SRC emacs-lisp
(require 'compile)
(setq compilation-error-regexp-alist-alist
      (cons '(node "^\\([a-zA-Z\.0-9\/-]+\\):\\([0-9]+\\)$"
                   1 ;; file
                   2 ;; line
                   )
            compilation-error-regexp-alist-alist))
(setq compilation-error-regexp-alist
      (cons 'node compilation-error-regexp-alist))

;; (add-hook 'js-mode-hook
;;           (lambda ()
;;             (set (make-local-variable 'compile-command)
;;                  (format "node %s" (file-name-nondirectory buffer-file-name)))))

#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq js-indent-level 2)

(add-hook 'js-mode-hook (lambda () (subword-mode t)))

(setq js2-mode-show-parse-errors nil
      js2-mode-show-strict-warnings nil
      js2-basic-offset 2
      js2-highlight-level 3
      css-indent-offset 2
      web-mode-markup-indent-offset 2
      web-mode-script-padding 0
      web-mode-css-indent-offset 2
      web-mode-style-padding 2
      web-mode-code-indent-offset 2
      web-mode-attr-indent-offset 2)

(use-package js2-mode
  :hook (js2-mode . flycheck-mode)
  :mode "\\.js\\'"
  :mode "\\.mjs\\'"
  :mode "\\.jsx\\'")

(use-package json-mode
  :mode "\\.json\\'"
  :mode "\\.eslintrc\\'")

(use-package coffee-mode
  :mode "\\.coffee\\'"
  :config
  (add-hook 'coffee-mode-hook (lambda () (subword-mode +1)))
  (custom-set-variables '(coffee-tab-width 2)))

(use-package typescript-mode
  :after tree-sitter
  :hook (js2-mode . flycheck-mode)
  :mode "\\.ts\\'"
  :mode "\\.mts\\'"
  :config
  (define-derived-mode typescriptreact-mode typescript-mode
    "TypeScript TSX")
   (add-to-list 'auto-mode-alist '("\\.tsx?\\'" . typescriptreact-mode) )
   (add-to-list 'tree-sitter-major-mode-language-alist '(typescriptreact-mode . tsx))
  )
#+END_SRC

Auto-format JavaScript on save
#+BEGIN_SRC emacs-lisp
(use-package prettier-js
  :diminish prettier-js-mode
  :hook (js2-mode . prettier-js-mode)
  :config
  (setq prettier-args '(
                        "--trailing-comma" "es5"
                        "--single-quote" "true"
                        )
        prettier-js-command (concat (getenv "HOME") "/.local/share/npm/bin/prettier")))

#+END_SRC

Context-coloring highlights code based on closures.
This gives a refreshing view of the code and helps using closures
efficiently.
#+BEGIN_SRC emacs-lisp
(use-package context-coloring
  :ensure t
  :hook ((js2-mode . context-coloring-mode))
  :bind (("C-c oc" . context-coloring-mode)))
#+END_SRC

*** React

The following shows an interesting way to quickly create
major modes _magically_. It parses the file to detect if this is a
react file. If yes I run a function to use web-mode and make some
adjustments for JSX.
#+BEGIN_SRC emacs-lisp
(add-to-list 'magic-mode-alist '("^import.*React.* from 'react'" . my-jsx-hook) )
(defun my-jsx-hook ()
  "Set web mode with adjustments for JSX"
  (interactive)
  (web-mode)
  (web-mode-set-content-type "jsx")
  (setq emmet-expand-jsx-className? t)
  (emmet-mode))
#+END_SRC
*** Vue
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode "\\.vue\\'"
  :mode "\\.tsx\\'"
  :config
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2)
  (setq web-mode-script-padding 0)
  (defun jjpandari/merge-imenu (index-fun)
    (interactive)
    (let ((mode-imenu (funcall index-fun))
          (custom-imenu (imenu--generic-function imenu-generic-expression)))
      (append custom-imenu mode-imenu)))

  ;; (use-package prettier-js
  ;;   :config
  ;;   (add-hook 'web-mode-hook (lambda ()
  ;;                              (enable-minor-mode
  ;;                               '("\\.vue?\\'" . prettier-js-mode)))))

  (add-hook 'web-mode-hook
            (lambda ()
              (setq imenu-create-index-function (lambda () (jjpandari/merge-imenu 'web-mode-imenu-index))))))

(require 'aurayb-narrow-indirect-vue)
#+END_SRC
** Rust
#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :bind (:map rust-mode-map
              ("C-c C-c" . rust-run)))
#+END_SRC
** WASM
#+begin_src emacs-lisp :results silent
(require 'wat-mode)
#+end_src
** Shell
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\aliases\\'" . shell-script-mode))
(add-to-list 'auto-mode-alist '("\\exports\\'" . shell-script-mode))
#+end_src

** Lisp
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.el\\'" . emacs-lisp-mode))
(define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eval-buffer)
#+end_src

** Elm
#+begin_src emacs-lisp
(use-package elm-mode)

#+end_src
* Bindings

** General
Shows a key combination helper in the minibuffer
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :diminish which-key-mode
  :config
  (which-key-mode))
#+END_SRC

Make grep buffers writable with ~C-c C-p~. Apply changes with ~C-c C-e~
#+BEGIN_SRC emacs-lisp
;; makes grep buffers writable and apply the changes to files.
(use-package wgrep :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package paredit
  :diminish paredit-mode
  :config
  (add-hook 'emacs-lisp-mode-hook #'paredit-mode)
  (add-hook 'clojure-mode-hook #'paredit-mode))

(use-package expand-region)

(global-display-line-numbers-mode -1)
(defun show-line-numbers ()
  (interactive)
  (setq display-line-numbers 'absolute))
(defun hide-line-numbers ()
  (interactive)
  (setq display-line-numbers 'nil))
(defun show-relative-line-numbers ()
  (interactive)
  (setq display-line-numbers 'relative))

(global-hl-line-mode -1)

(use-package rainbow-mode :diminish rainbow-mode)
(use-package windresize)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ivy-hydra)
(use-package general
  :config

  (general-create-definer my-leader-def
    :prefix "SPC")

  (my-leader-def
    :states 'normal
    :keymaps 'override
    "c" (lambda () (interactive) (org-capture nil "n"))
    "d" 'flycheck-list-errors
    "e" 'er/expand-region
    "f" 'counsel-rg
    "F" 'rg-project
    "h" 'highlight-symbol-at-point
    "H" 'unhighlight-regexp
    "i" 'counsel-imenu
    "o" 'recentf ;; o for oldfiles
    "p" 'project-find-file
    "s" 'auray/find-file-with-similar-name
    "t" 'tab-switcher
    "rr" 'eglot-code-actions
    "rq" 'eglot-code-action-quickfix
    "rn" 'eglot-rename
    "rf" 'eglot-format
    "w" 'er/contract-region
    "x" 'emamux:run-last-command
    "X" 'emamux:send-command
    )

  (my-leader-def
    :states 'visual
    :keymaps 'override
    "rr" 'eglot-code-actions
    "rq" 'eglot-code-action-quickfix
    "rn" 'eglot-rename
    "rf" 'eglot-format
    "x" 'emamux:send-region)

  (winner-mode 1)
  (general-define-key
   :states 'normal
   "-" 'dired-jump
   "gf" 'auray/project-guess-file
   "gr" 'er/expand-region
   "[ [" 'previous-buffer
   "] ]" 'next-buffer
   "] e" 'flycheck-next-error
   "[ e" 'flycheck-previous-error

   "[ q" 'previous-error
   "] q" 'next-error
   "]w" 'winner-redo
   "[w" 'winner-undo
   )

  (general-define-key
   :states 'insert
   "s-/" 'hippie-expand
   "M-/" 'hippie-expand)

  (general-define-key
   :keymaps 'override

   "s-t" 'project-find-file

   "<f5>" 'ispell-buffer
   "<f6>" 'iedit-mode
   "<f7>" 'org-tree-slide-mode
   "S-<f7>" 'org-tree-slide-skip-done-toggle
   ;; Hydra on F8
   "<f9>" 'deft

   "M-." 'xref-find-definitions
   "M-c" 'kill-ring-save ; ⌘-c = Copy
   "M-v" 'yank ; ⌘-v = Paste
   "M-x" 'counsel-M-x

   "C-h" 'tmux-move-left
   "C-j" 'tmux-move-down
   "C-l" 'tmux-move-right
   "C-k" 'tmux-move-up

   "C-r" 'isearch-backward
   "C-s" 'swiper

   "C-c C-m" 'execute-extended-command ; Another =M-x= without leaving the home row

   "C-c 9" 'paredit-backward-slurp-sexp
   "C-c 0" 'paredit-forward-slurp-sexp
   "C-c [" 'paredit-backward-barf-sexp
   "C-c ]" 'paredit-forward-barf-sexp
   "C-c a" 'org-agenda
   ;; C-c C-c "runs" what makes sense for a particular mode
   "C-c gg" 'magit-status

   "C-c gg" 'magit-status
   "C-c gf" 'magit-file-dispatch
   "C-c gl" 'git-link
   "C-c gt" 'git-timemachine-toggle
   "C-c jc" 'org-clock-jump-to-current-clock
   "C-c je" (lambda () (interactive) (find-file "~/.emacs.d/init.org"))
   "C-c jg" (lambda () (interactive) (find-file "~/Dropbox/notes/gtd.org"))
   "C-c jp" (lambda () (interactive) (find-file "~/projects/"))
   "C-c jw" (lambda () (interactive) (find-file "~/work"))
   "C-c jj" 'dired-jump
   "C-c k" 'recompile
   "C-c K" 'compile
   "C-c l" 'org-store-link

   "C-c of" 'auto-fill-mode
   "C-c og" 'global-hl-line-mode
   "C-c oi" 'electric-indent-mode
   "C-c olh" 'hide-line-numbers
   "C-c oll" 'show-line-numbers
   "C-c olr" 'show-relative-line-numbers
   "C-c op" 'show-paren-mode
   "C-c or" 'rainbow-mode
   "C-c ot" 'toggle-truncate-lines
   "C-c ow" 'visual-line-mode

   "C-c p" 'project-find-file
   "C-c R" 'revert-buffer
   "C-c w r" 'windresize

   "C-x C-m" 'counsel-M-x ; Another =M-x= without leaving the home row
   "C-x C-o" 'company-complete
   "C-x b" 'switch-to-buffer
   "C-x C-f" 'counsel-find-file
   "C-x B" 'project-switch-to-buffer
   "C-x m" 'execute-extended-command ; Another =M-x= without leaving the home row
   "C-x o" 'other-window)
  )
#+END_SRC

** Hydra

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :config
  (defhydra hydra-utils (global-map "<f8>")
    "drag"
    ("j" drag-stuff-down "down")
    ("k" drag-stuff-up "up")))

#+END_SRC

*** Drag stuff
#+BEGIN_SRC emacs-lisp
(use-package drag-stuff
  :diminish drag-stuff-mode
  :config
  (drag-stuff-global-mode t))
#+END_SRC

* Notes

Some people switch to Emacs just to use org-mode.

It is one of the best tool for note taking and writing

Setting the org-directory helps integration with org-agenda and
for org template captures.
#+BEGIN_SRC emacs-lisp
(setq org-directory "~/Dropbox/org")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'turn-on-auto-fill)

(require 'org-tempo) ;; shortcuts like <s <q to insert org block;

;; (require 'org-habit)
;; (add-to-list 'org-modules "org-habit")
;; (add-to-list 'org-modules "org-git-link")
(setq org-log-into-drawer t)

(setq org-todo-keywords
      '((sequence "TODO(t)" "STARTED(s!)" "WAITING(w@/!)" "|" "DONE(d!)" "CANCELED(canceled@)")))
#+END_SRC

** Navigate Notes
#+begin_src emacs-lisp :results silent
(use-package deft
  :commands (deft)
  :init
  (setq deft-extensions '("org" "md")
        deft-recursive t
        deft-directory "~/Dropbox/notes/"))
#+end_src
** Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :mode "\\.md\\'")
#+END_SRC
** Capture Ideas

~C-c l~ to store a link and ~C-c C-l~ to insert that link.

If you have a selection, it will be part of the link and Emacs will
look for that selection If you visit the link.

~palimpsest~ makes it easier to quickly discard blocks of text.
Main use is to just send the block of text at the bottom of the
buffer. This way I can revise my writing without losing my drafts.
~C-c C-q~ move region to trash
~C-c C-r~ move region to bottom
#+BEGIN_SRC emacs-lisp
(use-package palimpsest
  :diminish palimpsest-mode
  :config
  (add-hook 'org-mode-hook 'palimpsest-mode))
#+END_SRC

org-capture allows to set up templates for quick note taking.
This is a must to capture ideas quickly.
#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      '(("n" "Notes" entry (file+headline "~/Dropbox/org/inbox.org" "Inbox") "* %?\n")
        ("t" "todo" entry (file+headline "~/Dropbox/org/inbox.org" "Inbox")
         "* TODO [#A] %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n%a\n")))
#+END_SRC

To launch an Emacs client with a capture frame selecting the ~n~ template
~emacsclient -ca "" --frame-parameters='(quote (name .
"global-org-capture"))' -e '(org-capture nil "n")'~.

It works nicely on Linux and gives focus immediately.
On Mac I have an ~Alfred.app~ workflow to launch the command and give
focus to emacs.

The following takes advantage that I name those capture frame
~global-org-capture~ to do some housekeeping around them
#+BEGIN_SRC emacs-lisp
(defadvice org-capture-finalize
    (after delete-capture-frame activate)
  "Advise capture-finalize to close the frame"
  (if (equal "global-org-capture" (frame-parameter nil 'name))
      (progn
        (delete-frame))))

(defadvice org-capture-destroy
    (after delete-capture-frame activate)
  "Advise capture-destroy to close the frame"
  (if (equal "global-org-capture" (frame-parameter nil 'name))
      (progn
        (delete-frame))))

;; make the frame contain a single window. by default org-capture
;; splits the window.
(add-hook 'org-capture-mode-hook
          'delete-other-windows)
#+END_SRC

** Inline Code

Org babel allows to evaluate code snippets inside org files.
This is the best way I know of doing [[https://en.wikipedia.org/wiki/Literate_programming][Literate Programming]]

This loads more programming languages to use with org-babel.
#+BEGIN_SRC emacs-lisp
(require 'ob-clojure) ;; run cider-jack-in from org buffer to be able to run
;; clojure code
(use-package ob-clojurescript) ;; requires [[https://github.com/anmonteiro/lumo][lumo]]
(setq org-babel-clojure-backend 'cider)
(require 'ob-js)
(setq org-babel-js-function-wrapper "require('util').log(require('util').inspect(function(){%s}()));")
(org-babel-do-load-languages 'org-babel-load-languages
                             '((shell . t)
                               (sql . t)
                               (ditaa . t)))
(setq org-ditaa-jar-path "/usr/local/Cellar/ditaa/0.11.0/libexec/ditaa-0.11.0-standalone.jar")
#+END_SRC

** Publish
My strategy is to keep my writings in the same folder
~$HOME/Dropbox/org/writing~ and run ~org-publish-current-file~ or
~org-publish~ to export to HTML.

To get a preview
I run ~toggle-html-export-on-save~ when i work on a particular org file.
I use ~npm install -g simple-autoreload-server~ to auto-reload files
in my browser.
~autoreload-server -d ./ -p 1313~

#+BEGIN_SRC emacs-lisp
(setq
 time-stamp-active t
 time-stamp-line-limit 30     ; check first 30 buffer lines for Time-stamp:
 time-stamp-format "%04y-%02m-%02d") ;

(use-package writeroom-mode
  :bind (("C-c w w" . writeroom-mode)))

(use-package htmlize) ; for org html export
(setq system-time-locale "C") ; make sure time local is in english when exporting
(setq org-html-validation-link nil)
(setq org-publish-project-alist
      `(
        ("blog-files"
         :base-directory "~/perso/aurelienbottazini.github.io/_org"
         :base-extension "org"
         :publishing-directory "~/perso/aurelienbottazini.github.io/"
         :recursive t
         :publishing-function org-html-publish-to-html
         :headline-levels 4             ; Just the default for this project.
         :auto-preamble t
         :html-head-extra nil
         :body-only t
         )
        ;; ... add all the components here (see below)...
        ;; ("wiki" :components ("wiki-files"))
        )
      user-full-name "Aurélien Bottazini"
      org-export-with-toc t
      org-html-doctype "html5"
      org-html-head "<link rel=\"stylesheet\" type=\"text/css\" href=\"/css/main.css\" />"
      org-html-head-include-default-style nil
      org-html-head-include-scripts nil
      org-html-html5-fancy t
      org-html-postamble nil
      org-src-preserve-indentation nil
      org-html-htmlize-output-type "css"
      org-html-indent nil               ; a value other than nil will screw up src block indentation
      org-edit-src-content-indentation 0)

(add-hook 'org-mode-hook
          (lambda ()
            (setq-local time-stamp-start "Updated on[ 	]+\\\\?[\"<]+")
            (org-indent-mode t)
            (add-hook 'before-save-hook 'time-stamp nil 'local)))

(add-hook 'write-file-hooks 'time-stamp) ; update time-stamp on save
(require 'ox-publish)
(setq system-time-locale "C") ;; make sure time local is in english when exporting
(setq org-html-validation-link nil)

#+END_SRC
** Latex

[[https://emacs.stackexchange.com/questions/33010/how-to-word-wrap-within-code-blocks][How To break lines with code blocks]]
#+begin_src emacs-lisp
(add-to-list 'org-latex-packages-alist '("" "listings" nil))
(setq org-latex-listings t)
(setq org-latex-listings-options '(("breaklines" "true")
                                   ("literate" "{0}{0}{1}%
           {1}{1}{1}%
           {2}{2}{1}%
           {3}{3}{1}%
           {4}{4}{1}%
           {5}{5}{1}%
           {6}{6}{1}%
           {7}{7}{1}%
           {8}{8}{1}%
           {9}{9}{1}%
    ")))
#+end_src

** Feedback

Ispell buffer with ~F5~
Ispell word with ~z =~

Requires to install =hunspell= and =hunspell-fr=
#+begin_src shell :tangle no :dir  /sudo::
apt install hunspell hunspell-fr
#+end_src

#+BEGIN_SRC emacs-lisp :tangle no
(setq ispell-dictionary "en_US,fr_FR")
(setq ispell-program-name "hunspell")
(setq ispell-silently-savep t)
(setq ispell-personal-dictionary **local-personal-dictionary**)
;; Please note ispell-extra-args contains ACTUAL parameters passed to aspell
;; (setq ispell-extra-args '("--sug-mode=ultra"))
(ispell-set-spellchecker-params)
(ispell-hunspell-add-multi-dic "en_US,fr_FR")
(add-hook 'org-mode-hook 'turn-on-flyspell)
(eval-after-load "flyspell"
  '(diminish 'flyspell-mode))
#+END_SRC

For most documents, aim for a score of approximately 60 to 70 for
the reading ease and 7.0 to 8.0 for the grade level.
#+BEGIN_SRC emacs-lisp
(use-package writegood-mode)
#+END_SRC

If you need additional feedback from an external service here is an
easy way to do it:
#+BEGIN_SRC emacs-lisp
(require 'browse-url) ; part of gnu emacs

(defun my-lookup-wikipedia ()
  "Look up the word under cursor in Wikipedia.
If there is a text selection (a phrase), use that.

This command switches to browser."
  (interactive)
  (let (word)
    (setq word
          (if (use-region-p)
              (buffer-substring-no-properties (region-beginning) (region-end))
            (current-word)))
    (setq word (replace-regexp-in-string " " "_" word))
    (xwidget-webkit-browse-url (concat "http://en.wikipedia.org/wiki/" word))
    ;; (eww myUrl) ; emacs's own browser
    ))
#+END_SRC

* Search
Searching is probably the most important thing in a code editor.
Here is how I search.

** Search in current file/buffer

isearch and occur (~M-s o~)

** Search in project

#+begin_src emacs-lisp
(require 'auray/find-in-project)
#+end_src

**** From Dired
~C-x d~ to launch dired . I mark the files I am interested in with
~m~. Then I can grep those files with ~A~ and do a query replace
with ~Q~.

*** From Dired
~C-x d~ to launch dired . I mark the files I am interested in with
~m~. Then I can grep those files with ~A~ and do a query replace
with ~Q~.
** Rename

#+BEGIN_SRC emacs-lisp
(use-package iedit)
#+END_SRC

* VCS
Don't forget Emacs vcs features accessible with the prefix ~C-x v~!

** Resolving conflicts

This is to prevent popup windows when resolving file conflicts.
I prefer to have the ediff take over and restove the windows when
done.
#+BEGIN_SRC emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
(add-hook 'ediff-after-quit-hook-internal 'winner-undo)
(setq ediff-split-window-function 'split-window-vertically)
#+END_SRC

** Working with GitHub

To grab a link I can share with co-workers from the region or file.
#+BEGIN_SRC emacs-lisp
(use-package git-link)
#+END_SRC
** View History
*** vc-annotate

Bound to ~C-x v g~.
- Use ~l~ to see the commit message
- ~f~ to see what the file looked like at that revision. You can
  then use /git-link/ to grab a link with ~C-c gl~
- ~n~ and ~p~ to navigate between revisions
- ~=~ to see the diff.

  I prefer to use a full-window with vc-annotate
  #+BEGIN_SRC emacs-lisp
  (use-package fullframe
    :config
    (fullframe vc-annotate quit-window))
  #+END_SRC

** Magit

#+BEGIN_QUOTE
[[https://magit.vc/][Magit]] is an interface to the version control system Git, implemented
as an Emacs package. Magit aspires to be a complete Git porcelain.
While we cannot (yet) claim that Magit wraps and improves upon each
and every Git command, it is complete enough to allow even
experienced Git users to perform almost all of their daily version
control tasks directly from within Emacs. While many fine Git
clients exist, only Magit and Git itself deserve to be called
porcelains.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package magit
  :init
  (setq magit-commit-show-diff nil
        magit-auto-revert-mode nil
        magit-commit-show-diff nil))

(setq auth-sources '("~/.authinfo"))
#+END_SRC

#+begin_src emacs-lisp
(use-package forge
  :after magit)
#+end_src


When I use magit, I prefer to have it use the full emacs frame
instead of splitting the current buffer.
#+BEGIN_SRC emacs-lisp
(use-package fullframe
  :after magit
  :config
  (fullframe magit-status magit-mode-quit-window))
#+END_SRC

** Visual enhancements

See in the fringe lines added, changed and removed since last commit.
#+BEGIN_SRC emacs-lisp :tangle no
(use-package diff-hl
  :after magit
  :config
  (add-hook 'prog-mode-hook 'diff-hl-mode)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
#+END_SRC

* Projects
Emacs is not an IDE but It can be pretty close to one.
Here are some tools I use that are IDE oriented.

Emacs now includes ~project.el~ which helps managing projects

~C-x p~ as the default keybinding map
#+BEGIN_SRC emacs-lisp
(require 'project)
#+END_SRC

** Jump
/dumb-jump/ just do a search through the project to try to guess the
correct jump location for the current symbol. It is not has good as an
IDE code analysis but it works surprisingly well.

~M-.~ or ~gd~ to search from normal mode
~M-,~ to go back.
~M-?~ to find references
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :init
  :config
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+END_SRC

** Navigation tree
#+begin_src emacs-lisp
(setq speedbar-directory-unshown-regexp "^$")
#+end_src

** Find file in project
#+begin_src emacs-lisp
(setq project-switch-commands 'project-dired)
#+end_src

** LSP (with eglot)
#+begin_src emacs-lisp
(add-hook 'clojure-mode-hook 'eglot-ensure)
(add-hook 'js-mode-hook 'eglot-ensure)
(add-hook 'js2-mode-hook 'eglot-ensure)
(add-hook 'js-ts-mode-hook 'eglot-ensure)
#+end_src
* Completion
** Hippie expand
Bound to ~s-/~, it provides a simple on demand completion mechanism.
You can customize its behaviour by choosing different expand functions.

The description of all the hippie expand functions is inside
[[https://github.com/emacs-mirror/emacs/blob/master/lisp/hippie-exp.el#L63][~hippie-exp.el~]] (location can vary on your system)
#+BEGIN_SRC emacs-lisp
(setq hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-from-kill try-expand-all-abbrevs try-expand-list try-complete-file-name))
(require 'mode-local)
(setq-mode-local elisp-mode hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-from-kill try-expand-list try-complete-lisp-symbol-partially try-complete-lisp-symbol try-complete-file-name))
#+END_SRC

** Auto-Completion

company shows a popup where you can select completions with a number
or with ~enter~. You can also invoke the popup manually with ~C-x
C-o~

Use =company-diag= to debug completion problems
#+BEGIN_SRC emacs-lisp
(use-package company
  :demand t
  :diminish company-mode
  :config
  (setq company-idle-delay nil
        company-tooltip-limit 10
        company-tooltip-align-annotations t
        company-require-match 'never
        company-global-modes '(not eshell-mode comint-mode erc-mode message-mode help-mode gud-mode)
        company-frontends '(company-pseudo-tooltip-frontend company-echo-metadata-frontend)
        company-backends '((company-files company-capf))
        company-transformers '(company-sort-by-occurrence))

  (add-hook 'after-init-hook 'global-company-mode)
  (setq company-dabbrev-downcase nil
        company-dabbrev-ignore-case nil)
  (setq company-show-numbers t)

  (use-package company-statistics
    :after company
    :config
    (setq company-statistics-file "~/.emacs.d/company-stats-cache.el")
    (company-statistics-mode +1))

  (autoload 'company-capf "company-capf")
  (autoload 'company-yasnippet "company-yasnippet")
  (autoload 'company-elisp "company-elisp")
  (autoload 'company-files "company-files"))

#+END_SRC

** Snippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :defer 3
  :commands yas-expand-snippet
  :bind (("C-c y" . yas-insert-snippet))
  :diminish yas-minor-mode
  :init
  (setq yas-snippet-dirs
        '("~/.emacs.d/snippets"))
  :config
  (yas-global-mode 1)
  (add-hook 'term-mode-hook (lambda()
                              (yas-minor-mode -1))))
#+END_SRC

This allow me to automatically expand [[https://github.com/aurelienbottazini/dotfiles/blob/master/emacs/.emacs.d/templates/][templates]] into new files using
the yasnippet format. The filenames for the template are regexes.
#+BEGIN_SRC emacs-lisp :tangle no
(use-package yatemplate
  :config
  (add-hook 'find-file-hook 'auto-insert)
  (yatemplate-fill-alist))
#+END_SRC

* Files and directories
To play a video, with cursor on video file in dired =! vlc=

** Dired
#+BEGIN_SRC emacs-lisp
(setq ls-lisp-use-insert-directory-program t) ;same ls-lisp for Dired regardless of the platform
(setq dired-listing-switches "-alh")
;; on mac there is some weird prefixing going on for GNU Tools like ls.
;; I favor GNU ls over MacOSX default ls
(when (string-equal system-type "darwin")
  (setq insert-directory-program "/opt/homebrew/bin/gls"))

(require 'dired )
(defun my-dired-mode-setup ()
  "to be run as hook for `dired-mode'."
  (dired-hide-details-mode 1))
(add-hook 'dired-mode-hook 'my-dired-mode-setup)

(put 'dired-find-alternate-file 'disabled nil)
(setq dired-dwim-target t)
(add-hook 'dired-load-hook
          (lambda ()
            (load "dired-x")
            ;; Set dired-x global variables here.  For example:
            ;; (setq dired-guess-shell-gnutar "gtar")
            ;; (setq dired-x-hands-off-my-keys nil)
            (setq dired-recursive-copies (quote always)) ; “always” means no asking
            (setq dired-recursive-deletes (quote top)) ; “top” means ask once
            ))

(eval-after-load "dired"
  '(progn
     (define-key dired-mode-map "-" 'dired-up-directory)
     ))

(use-package dired-rsync
  :bind (:map dired-mode-map ("b" . dired-rsync)))
#+END_SRC
* 24 bits Emacs

Run this command to know if your Emacs display 24 bits colors.
Result should be 16777216
#+begin_src emacs-lisp :tangle no
(if (= 16777216 (display-color-cells))
    (message "24 bits color emacs")
  (message "Not 24 bits emacs"))
#+end_src

On Ubuntu 20.04 I had to [[https://github.com/aurelienbottazini/dotfiles/blob/dc400917364c9cc61d804e6d88c2c11b63da1c3c/home/.config/shell/aliases#L29][add a TERM env variable]] and add the
corresponding =terminfo= entry
#+begin_src shell
tic -o ~/.terminfo -x ~/.emacs.d/terminfo-emacs-rgb.src
#+end_src

Other =terminfo= examples are available in the [[https://www.gnu.org/software/emacs/manual/html_mono/efaq.html#Colors-on-a-TTY][emacs manual]]

* Documentation
#+BEGIN_SRC emacs-lisp
(use-package restclient
  :demand t
  :config
  (add-to-list 'auto-mode-alist '("\\.http\\'" . restclient-mode)))
#+END_SRC

* Presentation
#+begin_src emacs-lisp
(defun abott/org-tree-slide-play ()
  (writeroom-mode 1)
  (default-text-scale-increment 40))
(defun abott/org-tree-slide-stop ()
  (writeroom-mode -1)
  (default-text-scale-reset))

(use-package org-tree-slide
  :hook ((org-tree-slide-play . abott/org-tree-slide-play)
         (org-tree-slide-stop . abott/org-tree-slide-stop))
  :config
  (with-eval-after-load "org-tree-slide"
    (define-key org-tree-slide-mode-map (kbd "<f8>") 'org-tree-slide-move-previous-tree)
    (define-key org-tree-slide-mode-map (kbd "<f9>") 'org-tree-slide-move-next-tree)))
#+end_src

C-c C-e R =letter= to export a presentation from your org file

#+begin_src emacs-lisp
(use-package ox-reveal
  :config
  (setq org-reveal-root "file:///Users/auray/.emacs.d/site-lisp/reveal.js-4.1.0"))
#+end_src

* Testing

#+begin_src emacs-lisp
(pixel-scroll-precision-mode)
#+end_src

#+begin_src emacs-lisp
(use-package deadgrep)
#+end_src

#+begin_src emacs-lisp
(use-package emamux
  :commands (emamux:run-last-command emamux:send-command emamux:send-region)
  :init
  (setq emamux:use-nearest-pane 1))
#+end_src

#+begin_src emacs-lisp
(setq visible-bell t)
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

Sessions
#+begin_src emacs-lisp :tangle no
(desktop-save-mode)
#+end_src

#+begin_src emacs-lisp
(use-package evil
  :init (setq evil-want-C-i-jump nil)
  :config
  (define-key evil-normal-state-map (kbd "C-r") 'isearch-backward)
  (define-key evil-normal-state-map (kbd "C-n") 'next-line)
  (define-key evil-normal-state-map (kbd "C-p") 'previous-line)
  (define-key evil-normal-state-map (kbd "C-]") 'citre-jump)
  (define-key evil-normal-state-map (kbd "M-,") 'xref-pop-marker-stack)
  (define-key evil-normal-state-map (kbd "M-.") 'xref-find-definitions)
  (evil-mode 1)
)
#+end_src

Here is an awesome [[https://github.com/noctuid/evil-guide][Evil Guide]]

Quit read-only windows with Q instead of trying to register a Vim
Macro.
This is mainly to restore emacs behavior with help windows.
#+BEGIN_SRC emacs-lisp
(use-package evil
  :init
  :config
  (defun my-evil-record-macro ()
    (interactive)
    (if buffer-read-only
        (quit-window)
      (call-interactively 'evil-record-macro)))

  (with-eval-after-load 'evil-maps
    (define-key evil-normal-state-map (kbd "q") 'my-evil-record-macro)))

#+END_SRC

Surround things with
- ~S~ in visual mode
- ~ys<text-object>~ in normal mode
  You can also change surroundings ~cs~ or delete surroundings ~ds~.
#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :after evil
  :config
  (global-evil-surround-mode 1))
#+END_SRC

I use Vim keybindings everywhere except with special modes

like Magit, Dired... I setup those special modes to start with Emacs
keybindings by default.
#+begin_src emacs-lisp
(use-package evil
  :config
  (evil-set-initial-state 'deadgrep-mode 'emacs)
  (evil-set-initial-state 'rg-mode 'emacs)
  (evil-set-initial-state 'deft-mode 'insert)
  (evil-set-initial-state 'dired-mode 'emacs)
  (evil-set-initial-state 'magit-mode 'emacs)
  (evil-set-initial-state 'use-package-statistics 'emacs)
  (evil-set-initial-state 'xref--xref-buffer-mode 'emacs)
  (evil-set-initial-state 'term-mode 'emacs)
  (evil-set-initial-state 'ert-results-mode 'emacs)
  (evil-set-initial-state 'vterm-mode 'emacs)
  (evil-set-initial-state 'shell-mode 'emacs)
  (evil-set-initial-state 'tab-switcher-mode 'emacs)
  (evil-set-initial-state 'cider-inspector-mode 'emacs)
  (evil-set-initial-state 'ivy-occur-mode 'emacs)
  (evil-set-initial-state 'ivy-occur-grep-mode 'emacs)
  (evil-set-initial-state 'ivy-occur-grep-mode 'emacs)
  (evil-set-initial-state 'inf-ruby-mode 'emacs)
  (evil-set-initial-state 'compilation-mode 'emacs)

  ;; magit commit
  (add-hook 'with-editor-mode-hook 'evil-insert-state))

#+end_src


Comment things with ~gc~. Comment and copy with ~gy~
#+BEGIN_SRC emacs-lisp
(use-package evil-commentary
  :after evil
  :diminish evil-commentary-mode
  :config
  (evil-commentary-mode))
#+END_SRC

Start a search from visual selection with ~*~ or ~#~ (backward).
#+BEGIN_SRC emacs-lisp
(use-package evil-visualstar
  :after evil
  :config
  (evil-define-key nil evil-normal-state-map (kbd "k") 'evil-previous-visual-line)
  (evil-define-key nil evil-normal-state-map (kbd "j") 'evil-next-visual-line)
  (global-evil-visualstar-mode t))
#+END_SRC

Jump to matching pairs with ~%~.
#+BEGIN_SRC emacs-lisp
(use-package evil-matchit
  :defer 2
  :after evil
  :config
  (global-evil-matchit-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package evil
  :init (setq evil-want-C-i-jump nil)
  :config
  (evil-ex-define-cmd "W" 'save-buffer))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package evil
  :config
  (setq evil-want-C-i-jump nil)
  (evil-define-key 'insert lisp-interaction-mode-map (kbd "C-c C-c") 'eval-print-last-sexp))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package key-chord
  :after evil
  :config
  (key-chord-mode 1)
  (key-chord-define evil-insert-state-map  "jk" 'evil-normal-state))
#+END_SRC

#+begin_src emacs-lisp :tangle no
(use-package treesit-auto
  :config
  (global-treesit-auto-mode))
#+end_src

#+begin_src emacs-lisp :tangle no
(fido-mode t)
(fido-vertical-mode)
#+end_src

#+begin_src emacs-lisp
(use-package haskell-mode)
#+end_src

#+begin_src emacs-lisp
(use-package rg)
#+end_src

#+begin_src emacs-lisp
(use-package sqlite3)
#+end_src

#+begin_src emacs-lisp
(use-package exec-path-from-shell)
(exec-path-from-shell-copy-env "SSH_AGENT_PID")
(exec-path-from-shell-copy-env "SSH_AUTH_SOCK")
#+end_src

#+begin_src emacs-lisp
(use-package multiple-cursors)
(use-package counsel
  :diminish counsel-mode ivy-mode
  :config
  (ivy-mode t)
  (define-key ivy-minibuffer-map (kbd "C-c r") 'ivy-restrict-to-matches)
  (counsel-mode t))
#+end_src

#+begin_src emacs-lisp
(require 'tramp)
(add-to-list 'tramp-remote-path "~/.local/share/npm/bin/")
(add-to-list 'tramp-remote-path 'tramp-own-remote-path)
#+end_src


Speed up tramp
#+begin_src emacs-lisp
(setq vc-ignore-dir-regexp
      (format "\\(%s\\)\\|\\(%s\\)"
              vc-ignore-dir-regexp
              tramp-file-name-regexp))
#+end_src

#+begin_src emacs-lisp
(use-package graphql-mode)
#+end_src

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook ((prog-mode . rainbow-delimiters-mode)))
#+end_src

#+begin_src emacs-lisp
(use-package highlight-blocks)
;; (add-hook 'prog-mode-hook 'highlight-blocks-mode)
#+end_src

#+begin_src emacs-lisp
(setq evil-insert-state-cursor '((bar . 2) "#97d88a")
      evil-normal-state-cursor '(box "#ffaf00")
      evil-visual-state-cursor '(box "#afcff1")
      evil-emacs-state-cursor '((bar . 2) "#ffffd7")

        )
#+end_src

* Local variables

#+begin_src emacs-lisp
(defun auray/bg-modeline-color-from-evil-state ()
  (interactive)
  (cond ((evil-insert-state-p) "#97d88a")
        ((evil-visual-state-p) "#adcff1")
        ((evil-emacs-state-p) "#4c7073")
        ((evil-normal-state-p) "#ffaf00")
        (t "#32302f")))

(defun auray/fg-modeline-color-from-evil-state ()
  (interactive)
  (cond ((evil-insert-state-p) "#262626")
        ((evil-visual-state-p) "#262626")
        ((evil-emacs-state-p) "#ffffd7")
        ((evil-normal-state-p) "#262626")
        (t "#ffffd7")))

(defun auray/post-command-evil-modeline-colors-hook ()
  (interactive)
  (set-face-background 'mode-line (auray/bg-modeline-color-from-evil-state))
  (set-face-foreground 'mode-line (auray/fg-modeline-color-from-evil-state)))

(add-hook 'post-command-hook 'auray/post-command-evil-modeline-colors-hook)
#+end_src

#+begin_src emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
#+end_src

#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 6))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
(use-package chatgpt
  :straight (:host github :repo "joshcho/ChatGPT.el" :files ("dist" "*.el"))
  :bind ("C-c q" . chatgpt-code-query))
#+end_src

#+begin_src emacs-lisp
(use-package copilot
  :straight (:host github :repo "zerolfx/copilot.el" :files ("dist" "*.el"))
  :ensure t
  ;; :hook (prog-mode . copilot-mode)
  :bind (:map copilot-completion-map
              ("<tab>" . 'copilot-accept-completion)
              ("TAB" . 'copilot-accept-completion)
              ("C-TAB" . 'copilot-accept-completion-by-word)
              ("C-<tab>" . 'copilot-accept-completion-by-word)))
#+end_src

#+begin_src emacs-lisp
(use-package projectile)
(use-package citre
  :init
  ;; (require 'citre-config)
  ;; Bind your frequently used commands.  Alternatively, you can define them
  ;; in `citre-mode-map' so you can only use them when `citre-mode' is enabled.
  (global-set-key (kbd "C-x c j") 'citre-jump)
  (global-set-key (kbd "C-x c J") 'citre-jump-back)
  (global-set-key (kbd "C-x c p") 'citre-ace-peek)
  (global-set-key (kbd "C-x c u") 'citre-update-this-tags-file)
  :config
  (setq
   citre-use-project-root-when-creating-tags t
   citre-prompt-language-for-ctags-command t
   ;; By default, when you open any file, and a tags file can be found for it,
   ;; `citre-mode' is automatically enabled.  If you only want this to work for
   ;; certain modes (like `prog-mode'), set it like this.
   citre-auto-enable-citre-mode-modes '(prog-mode)
)
)
#+end_src

#+begin_src emacs-lisp
(use-package origami)
(add-hook 'prog-mode-hook 'origami-mode)
#+end_src

#+begin_src emacs-lisp
(use-package rubocopfmt
  :hook
  (ruby-mode . rubocopfmt-mode)
  (ruby-ts-mode . rubocopfmt-mode)
  )
#+end_src

#+begin_src emacs-lisp
(use-package projectile-rails
  :config
  (projectile-rails-global-mode)
(define-key projectile-rails-mode-map (kbd "C-c n") 'projectile-rails-command-map))
#+end_src

#+begin_src emacs-lisp
(setq find-sibling-rules
      '(
               ("app/[^/]+/\\(.*\\).rb\\'" "spec/.*/\\1_spec.rb")
               ("spec/[^/]+/\\(.*\\)_spec.rb\\'" "app/.*/\\1.rb")
               ))
#+end_src
# Local Variables:
# eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
# End:
