#+TITLE: Aurélien Bottazini's Emacs configuration
#+OPTIONS: toc:4 h:4
#+PROPERTY: header-args :results silent :tangle yes

Adjusts garbage collector for faster startup.
#+begin_src emacs-lisp :results silent
;; -*- lexical-binding: t; -*-
(defvar last-file-name-handler-alist file-name-handler-alist)
(setq gc-cons-threshold 402653184
      gc-cons-percentage 0.6
      file-name-handler-alist nil)

(add-hook 'emacs-startup-hook (lambda ()
                                (setq gc-cons-threshold 16777216
                                      gc-cons-percentage 0.1
                                      file-name-handler-alist last-file-name-handler-alist)))
#+end_src

* Debug Emacs

If Emacs complains about a mismatched paren while trying to start
you can use ~check-parens~ to find the mismatched parenthesis.
#+begin_src emacs-lisp :tangle no
(check-parens)
#+end_src

Emacs tends to swallow errors.
If something is not working correctly there is a good chance you will
discover what is wrong by turning on ~toggle-debug-on-error~
#+begin_src emacs-lisp :tangle yes
(toggle-debug-on-error)
#+end_src

If a command is slow you can investigage with
#+begin_src emacs-lisp :tangle no
(profiler-start)
;; run your slow command
(profiler-report)
#+end_src

* Setup

Zenburn is one of the most complete theme out there. It also works
well on the terminal.
#+BEGIN_SRC emacs-lisp
  (use-package zenburn-theme
   :config
   (load-theme 'zenburn t))
#+END_SRC

It is important to load custom settings early. Those are the ones
managed by Emacs through customization menus. They can impact the
loading of other packages.
#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load custom-file)
#+END_SRC

As I work on different computers, I need slightly different
settings. Instead of embedding machine specific code through
conditionals, I use a file to load machine specifics global
variables that are used in other parts of this configuration. I have
a small convention for the names. I surround them with double stars
and the name starts with local. Ex: ~(setq **local-my-variable**
"foo/bar")~.
#+BEGIN_SRC emacs-lisp
  (if (file-exists-p "~/.emacs.d/.emacs-local")
    (load "~/.emacs.d/.emacs-local"))
#+END_SRC

I keep elisp I write, or elisp not available on melpa inside the
site-lisp directory. The files in that directory are automatically
added to the Emacs load-path.
#+BEGIN_SRC emacs-lisp
  (let ((default-directory  "~/.emacs.d/site-lisp/"))
    (normal-top-level-add-to-load-path '("."))
    (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

A special keymap ~my-keys-minor-mode-map~ to store my global
keybindings. This is to make sure that any key I define in my keymap
as priority over ones defined elsewhere by built-in Emacs modes or 3rd
party packages.
#+BEGIN_SRC emacs-lisp
  (defvar my-keys-minor-mode-map (make-keymap) "my-keys-minor-mode keymap.")
  (define-minor-mode my-keys-minor-mode
    "A minor mode so that my key settings override annoying major modes."
    t " my-keys" 'my-keys-minor-mode-map)
  (my-keys-minor-mode 1)

  (defadvice load (after give-my-keybindings-priority)
    "Try to ensure that my keybindings always have priority."
    (if (not (eq (car (car minor-mode-map-alist)) 'my-keys-minor-mode))
        (let ((mykeys (assq 'my-keys-minor-mode minor-mode-map-alist)))
          (assq-delete-all 'my-keys-minor-mode minor-mode-map-alist)
          (add-to-list 'minor-mode-map-alist mykeys))))
  (ad-activate 'load)
#+END_SRC

If for any reason I encounter other modes where the Vim keybindings
are interfering too much, I can disable the Vim keybindings with
~evil-toggle-key~.
#+BEGIN_SRC emacs-lisp
(setq evil-toggle-key "C-c e")
(define-key my-keys-minor-mode-map "\C-z" 'suspend-frame)
#+END_SRC

** Package library initialization
#+BEGIN_SRC emacs-lisp
(setq package-archives
      '(("melpa"       . "https://melpa.org/packages/")
        ("org"         . "https://orgmode.org/elpa/")
        ("gnu"         . "http://elpa.gnu.org/packages/")))

(use-package org)

(setq package-user-dir (concat user-emacs-directory "elpa"))

;; this tells package.el not to add those pesky customized variable settings at
;; the end of your init.el
(setq package--init-file-ensured t)

(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))

(defun require-package (package &optional min-version)
  "Ask elpa to install given PACKAGE. You can specify a MIN-VERSION for your PACKAGE."
  (unless (package-installed-p package min-version)
    (package-install package)))

(require-package 'use-package)
(require 'use-package)

(setq use-package-compute-statistics t) ;(use-package-report) to show  which package is slow to start.
(setq use-package-always-ensure t) ; Install package if it is missing
#+END_SRC

You can get the time it took for emacs to start with.
#+BEGIN_SRC emacs-lisp :tangle no
   (emacs-init-time)
#+END_SRC

** Local variables
Local variables are useful to customize your settings for different
projects/directories. The built in ~make-local-variable~ is
convenient in helping you create those variables.

It is annoying when I edit those local variables that they are not
picked up automatically for open buffers. Those two functions help me
with the reloading of those locals.
#+BEGIN_SRC emacs-lisp
(defun my-reload-dir-locals-for-current-buffer ()
  "Reloads dir locals for the current buffer."
  (interactive)
  (let ((enable-local-variables :all))
    (hack-dir-local-variables-non-file-buffer)))

(defun my-reload-dir-locals-for-all-buffer-in-this-directory ()
  "For every buffer with the same `default-directory` as the current buffer's, reload dir-locals."
  (interactive)
  (let ((dir default-directory))
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (when (equal default-directory dir))
        (my-reload-dir-locals-for-current-buffer)))))
#+END_SRC

** Better Defaults
I like setting the path manually as other solutions like ~exec-path-from-shell~
can slow down Emacs startup if the shells scripts do too many things.

`exec-path` is used by Emacs to find executables.
`PATH` is used by Emacs when you are running a shell in Emacs.
It make things easier when the two match.
#+BEGIN_SRC emacs-lisp
(setenv "JAVA_HOME" "/Library/Java/JavaVirtualMachines/adoptopenjdk-12.0.2.jdk/Contents/Home")
(let* ((home-folder (getenv "HOME"))
      (my-paths `("/home/linuxbrew/.linuxbrew/bin/"
                  ,(concat home-folder "/.config/yarn/global/node_modules/.bin/")
                  ,(concat home-folder "/.local/share/n/bin")
                  ,(concat home-folder "/work/dox-compose/bin/")
                  ,(concat home-folder "/.rbenv/bin/")
                  ,(concat home-folder "/.rbenv/shims/")
                  ,(concat home-folder "/dotfiles/bin/")
                  ,(concat home-folder "/.fzf/bin")
                  ,(concat home-folder "/.local/bin")
                  ,(concat home-folder "/.local/share/npm/bin/")
                  ,(concat home-folder "/bin")
                  "/mnt/c/WINDOWS/System32/WindowsPowerShell/v1.0/"
                  "/usr/local/opt/node@10/bin/"
                  "/usr/local/bin"
                  "/bin/"
                  "/usr/local/sbin/"
                  "/usr/bin/"))
      )
  (setenv "PATH" (mapconcat 'identity my-paths ":" ))
  (setq exec-path my-paths))
#+END_SRC

Emacs can be really fast with large files too. The trick is to
stick to fundamental mode and disable expensive minor modes.
#+BEGIN_SRC emacs-lisp
(defun check-large-file-hook ()
  "If a file is over a given size, turn off minor modes."
  (when (> (buffer-size) (* 1024 100)) ; 100K
    (fundamental-mode)
    (font-lock-mode -1)
    (setq buffer-read-only t)
    (buffer-disable-undo)))

(add-hook 'find-file-hooks 'check-large-file-hook)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq help-window-select t ; if an help window appears, give it focus
      inhibit-startup-message t
      default-indicate-empty-lines nil ; show end of buffer on left fringe
      tab-always-indent 'complete ; try to indent first, if already indented try to complete
)

(make-variable-buffer-local 'compile-command) ; makes the compile command be buffer specific.
(defalias 'yes-or-no-p 'y-or-n-p) ; instead of typing yes or no, type y or n
(setq ring-bell-function 'ignore) ; please don't startle me with a bell!

(setq backup-by-copying t      ; don't clobber symlinks
      backup-directory-alist
      '((".*" . "~/.local/share/emacs-saves"))    ; don't litter my fs tree
      delete-old-versions t
      kept-new-versions 6
      kept-old-versions 2
      delete-by-moving-to-trash t
      auto-save-default t ;files starting with # are generated by autosave
      auto-save-timeout 60 ; number of seconds before auto-saving
      auto-save-interval 200 ; number of keystrokes before auto-saves
      version-control t ; use versioned backups
      create-lockfiles nil
      auto-save-file-name-transforms `((".*" ,"~/.local/share/emacs-saves" t))
)

(setq global-auto-revert-non-file-buffers t) ; also auto-revert dired buffers and other special buffers

;; if file has no change, just load any changes
;; coming from an external process
(global-auto-revert-mode 1)

;; replace selected text when typing. Not very useful as I use vim keybindings.
;; Still nice to have as a default
(pending-delete-mode 1)

(prefer-coding-system 'utf-8)
(modify-coding-system-alist 'process "\\*compilation\\*\\'"   'utf-8)

(set-default 'truncate-lines t) ; gives each line only one visual line and don't show a continuation on next line
#+END_SRC

Sentences end with one space after point. The default two space is
an historical setting. This makes Emacs sentence based commands follow
the modern standard.
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

I want error highlights and error bindings in shell modes too.
#+BEGIN_SRC emacs-lisp
(add-hook 'shell-mode-hook 'compilation-shell-minor-mode)
#+END_SRC

~C-c C-w~ to copy regex
~C-c C-q~ to quit re-builder and to remove highlights
#+BEGIN_SRC emacs-lisp
(require 're-builder)
(setq reb-re-syntax 'string)
#+END_SRC

*** tabs and white-space
By default I disable tabs. I use ~whitespace-mode~ in programming
buffers because sometimes when copy pasting code from external
sources those external sources have tabs. I want to see those tabs
to remove them.

I don't use the ~global-whitespace-mode~ as some emacs mode like
~magit~ use tabs.

You can remove all tabs from your buffer with ~untabify~

#+BEGIN_SRC emacs-lisp
(setq-default
 indent-tabs-mode nil    ; no tabs
 c-basic-offset 2)
#+END_SRC

Makes trailing white space and tabs visible.
#+BEGIN_SRC emacs-lisp
(setq-default whitespace-style '(face trailing tabs tab-mark))
#+END_SRC

Clean white space on save.
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
(add-hook 'prog-mode-hook 'whitespace-mode)
(eval-after-load "whitespace"
  '(diminish 'whitespace-mode))
#+END_SRC

*** Recent files
#+BEGIN_SRC emacs-lisp
(recentf-mode 1)
(setq recentf-max-menu-items 200)
(setq recentf-max-saved-items 200)
#+END_SRC

* Utility functions

You can switch to root permissions with ivy with M-o r.
This small function makes it easier for the current file.
#+BEGIN_SRC emacs-lisp
(defun sudo ()
  "Use TRAMP to `sudo' the file for current buffer."
  (interactive)
  (when buffer-file-name
    (find-alternate-file
     (concat "/sudo:root@localhost:"
             buffer-file-name))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun enable-minor-mode (my-pair)
  "Enable minor mode if filename match the regexp. MY-PAIR is a
cons cell (regexp . minor-mode)."
  (if (buffer-file-name)
      (if (string-match (car my-pair) buffer-file-name)
          (funcall (cdr my-pair)))))

(defun filepath-with-line-number-for-current-buffer ()
  "Return a string with Buffer-file-name:line-number.
             Make it easier to prepare commands for tools like rspec"
  (interactive)
  (concat (buffer-file-name) ":" (number-to-string (line-number-at-pos))))

(defun add-date-to-filename ()
  "Add current date in front of filename for current buffer. This is useful with some
        Blog tools like Jekyll to publish new articles."
  (interactive)
  (let* ((date (format-time-string "%Y-%m-%d"))
         (buffer-file (buffer-file-name))
         (new-file-name (concat (file-name-directory buffer-file)
                                date
                                "-"
                                (file-name-nondirectory buffer-file)))
         )
    (rename-file buffer-file new-file-name)
    (set-visited-file-name new-file-name)
    (save-buffer)))

(defun toggle-html-export-on-save ()
  "Enable or disable HTML export when saving current org buffer."
  (interactive)
  (when (not (eq major-mode 'org-mode))
    (error "Not an org-mode file!"))
  (if (memq 'org-html-export-to-html after-save-hook)
      (progn (remove-hook 'after-save-hook 'org-html-export-to-html t)
             (message "Disabled org html export on save"))
    (add-hook 'after-save-hook 'org-publish-current-file nil t)
    (set-buffer-modified-p t)
    (message "Enabled org html export on save")))


(defun abo-jump-to-note-file ()
  "Jump to org note file for current buffer"
  (interactive)
  (find-file **local-note-file**))
(define-key my-keys-minor-mode-map "\C-cn" 'abo-jump-to-note-file)

(defun abo-change-line-endings-to-unix ()
  (let ((coding-str (symbol-name buffer-file-coding-system)))
    (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
      (set-buffer-file-coding-system 'unix))))
#+END_SRC

* GUI
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
(column-number-mode) ; column number in the mode line

(electric-indent-mode t)

(electric-pair-mode nil)
(defun inhibit-electric-pair-mode-in-minibuffer (char)
  (minibufferp))
(setq electric-pair-inhibit-predicate #'inhibit-electric-pair-mode-in-minibuffer)

(setq frame-title-format "emacs")

(setq blink-matching-paren 'jump-offscreen)

;; makes fringe big enough with HDPI
(when (boundp 'fringe-mode)
  (fringe-mode 20))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package diminish
  :config
  (eval-after-load "undo-tree"
    '(diminish 'undo-tree-mode))
    (eval-after-load "subword"
    '(diminish 'subword-mode))
  (diminish 'auto-fill-function)
  (diminish 'my-keys-minor-mode)
  (diminish 'eldoc-mode))
#+END_SRC
* Windows
Splitting can be done with ~C-x 2~ and ~C-x 3~  or with
~C-w v~ and ~C-w s~ to split vertically and horizontally.

Move between buffers with C-h C-j C-k C-l. My Tmux bindings are made
to [[https://github.com/aurelienbottazini/dotfiles/blob/6cb8e100568cffb788f0ecd8488e4a4fd50349cd/tmux/.config/tmux/tmux.conf#L31-L35][make it work seamlessly]] with Emacs.
#+BEGIN_SRC emacs-lisp
(defun tmux-socket-command-string ()
  (interactive)
  (concat "tmux -S "
          (replace-regexp-in-string "\n\\'" ""
                                    (shell-command-to-string "echo $TMUX | sed -e 's/,.*//g'"))))

(defun tmux-move-right ()
  (interactive)
  (condition-case nil
      (evil-window-right 1)
    (error (unless window-system (shell-command (concat
                                                 (tmux-socket-command-string) " select-pane -R") nil)))))

(defun tmux-move-left ()
  (interactive)
  (condition-case nil
      (evil-window-left 1)
    (error (unless window-system (shell-command (concat
                                                 (tmux-socket-command-string) " select-pane -L") nil)))))

(defun tmux-move-up ()
  (interactive)
  (condition-case nil
      (evil-window-up 1)
    (error (unless window-system (shell-command (concat
                                                 (tmux-socket-command-string) " select-pane -U") nil)))))

(defun tmux-move-down ()
  (interactive)
  (condition-case nil
      (evil-window-down 1)
    (error (unless window-system (shell-command (concat
                                                 (tmux-socket-command-string) " select-pane -D") nil)))))

(define-key my-keys-minor-mode-map (kbd "C-h") 'tmux-move-left)
(define-key my-keys-minor-mode-map (kbd "C-j") 'tmux-move-down)
(define-key my-keys-minor-mode-map (kbd "C-k") 'tmux-move-up)
(define-key my-keys-minor-mode-map (kbd "C-l") 'tmux-move-right)
#+END_SRC
* Programming languages

Auto-fill comments in prog modes
#+BEGIN_SRC emacs-lisp
(defun my-prog-mode-auto-fill-hook ()
  (setq fill-column 80)
  (set (make-local-variable 'comment-auto-fill-only-comments) t)
  (auto-fill-mode t))
(add-hook 'prog-mode-hook 'my-prog-mode-auto-fill-hook)
#+END_SRC

** Clojure
#+BEGIN_SRC emacs-lisp
(use-package clojure-mode
  :mode "\\.clj\\'"
  :config
  (add-hook 'clojure-mode-hook #'subword-mode)
  (use-package cider))
#+END_SRC
** Ruby
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :mode "\\.ya?ml\\'")

(use-package ruby-mode
  :mode "\\.rake\\'"
  :mode "Rakefile\\'"
  :mode "\\.gemspec\\'"
  :mode "\\.ru\\'"
  :mode "Gemfile\\'"
  :mode "Guardfile\\'"
  :mode "Capfile\\'"
  :mode "\\.cap\\'"
  :mode "\\.thor\\'"
  :mode "\\.rabl\\'"
  :mode "Thorfile\\'"
  :mode "Vagrantfile\\'"
  :mode "\\.jbuilder\\'"
  :mode "Podfile\\'"
  :mode "\\.podspec\\'"
  :mode "Puppetfile\\'"
  :mode "Berksfile\\'"
  :mode "Appraisals\\'"
  :mode "\\.rb$"
  :mode "ruby"
  :config

  (add-hook 'ruby-mode-hook 'subword-mode)

  (define-key ruby-mode-map (kbd "C-c C-c") 'xmp)
  (use-package ruby-interpolation
    :diminish ruby-interpolation-mode)
  (use-package ruby-end
    :diminish ruby-end-mode
    :config
    (defun ruby-end-insert-end ()
      "Closes block by inserting end."
      (save-excursion
        (newline)
        (insert "end")
        (indent-according-to-mode)))
    )
  (use-package rspec-mode))
#+END_SRC

I learned about this on [[http://www.virtuouscode.com/2013/06/24/rubytapas-freebie-xmpfilter/][Ruby Tapas.]] Hit ~M-;~ twice adds a special
comment for xmpfilter. Running ~xmp~ will evaluate the line and put
the result after the comment.
#+BEGIN_SRC emacs-lisp
(require 'rcodetools)
(defadvice comment-dwim (around rct-hack activate)
    "If comment-dwim is successively called, add => mark."
    (if (and (or (eq major-mode 'enh-ruby-mode)
                 (eq major-mode 'ruby-mode))
             (eq last-command 'comment-dwim))
        (progn
          (if (eq major-mode 'enh-ruby-mode)
              (end-of-line))
          (insert "=>"))
      ad-do-it))
#+END_SRC
** Go

#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :mode "\\.go\\'")
#+END_SRC

** HTML

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode "\\.html\\'"
  :mode "\\.gohtml\\'"
  :config
  (setq web-mode-enable-auto-closing t))

(use-package emmet-mode
  :hook (css-mode sgml-mode web-mode)
  :after evil
  :diminish emmet-mode
  :config
  (progn
    (evil-define-key 'insert emmet-mode-keymap (kbd "C-j") 'emmet-expand-line)
    (evil-define-key 'emacs emmet-mode-keymap (kbd "C-j") 'emmet-expand-line))

  (add-hook 'css-mode-hook
            (lambda ()
              (emmet-mode)
              (setq emmet-expand-jsx-className? nil)))

  (add-hook 'sgml-mode-hook
            (lambda ()
              (emmet-mode)
              (setq emmet-expand-jsx-className? nil))))
#+END_SRC

** CSS
#+BEGIN_SRC emacs-lisp
(use-package scss-mode :mode "\\.scss\\'")

(use-package sass-mode :mode "\\.sass\\'")

(use-package less-css-mode :mode "\\.less\\'")
#+END_SRC
** JavaScript
Node compilation errors messages are not understood by Emacs by
default. All that's needed to make it work is to add a new regex
describing what are the components of the messages.

After running the compile command, you can navigate through the
errors with ~next-error~ and ~previous-error~
#+BEGIN_SRC emacs-lisp
(require 'compile)
(setq compilation-error-regexp-alist-alist
      (cons '(node "^\\([a-zA-Z\.0-9\/-]+\\):\\([0-9]+\\)$"
                   1 ;; file
                   2 ;; line
                   )
            compilation-error-regexp-alist-alist))
(setq compilation-error-regexp-alist
      (cons 'node compilation-error-regexp-alist))

(add-hook 'js2-mode-hook
          (lambda ()
            (set (make-local-variable 'compile-command)
                 (format "node %s" (file-name-nondirectory buffer-file-name)))))

#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq js-indent-level 2)

(use-package js2-mode
  :mode "\\.js\\'"
  :mode "\\.jsx\\'"
  :config
  (setq js2-mode-show-parse-errors nil
        js2-mode-show-strict-warnings nil
        js2-basic-offset 2
        js2-highlight-level 3
        css-indent-offset 2
        web-mode-markup-indent-offset 2
        web-mode-script-padding 0
        web-mode-css-indent-offset 2
        web-mode-style-padding 2
        web-mode-code-indent-offset 2
        web-mode-attr-indent-offset 2)
  :config
  (add-hook 'js2-mode-hook 'js2-imenu-extras-mode)
  (add-hook 'js2-mode-hook 'js2-imenu-extras-mode)
  (add-hook 'js2-mode-hook (lambda() (subword-mode t)))

  ;; (use-package xref-js2
  ;;   :init
  ;;   (setq xref-js2-search-program 'rg)
  ;;   :config
  ;;   (add-hook 'js2-mode-hook (lambda () (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t))))

(use-package json-mode
  :mode "\\.json\\'"
  :mode "\\.eslintrc\\'")

(use-package coffee-mode
  :mode "\\.coffee\\'"
  :config
  (use-package highlight-indentation)
  (add-hook 'coffee-mode-hook '(lambda () (highlight-indentation-mode)))
  (add-hook 'coffee-mode-hook '(lambda () (subword-mode +1)))
  (custom-set-variables '(coffee-tab-width 2)))

(use-package typescript-mode
  :mode "\\.ts\\'")
#+END_SRC

Auto-format JavaScript on save
#+BEGIN_SRC emacs-lisp
   (use-package prettier-js
     :diminish prettier-js-mode
     :config
     (setq prettier-args '(
                           "--trailing-comma" "es5"
                           "--single-quote" "true"
                           )
           prettier-js-command "prettier")
     (add-hook 'js2-mode-hook #'js2-imenu-extras-mode))
#+END_SRC

Context-coloring highlights code based on closures.
This gives a refreshing view of the code and helps using closures
efficiently.
#+BEGIN_SRC emacs-lisp
   (use-package context-coloring
     :ensure t
     :diminish context-coloring-mode
     :bind (:map my-keys-minor-mode-map ("C-c oc" . context-coloring-mode))
     :config
     (add-hook 'js2-mode-hook 'context-coloring-mode))
#+END_SRC

*** React

The following shows an interesting way to quickly create
major modes _magically_. It parses the file to detect if this is a
react file. If yes I run a function to use web-mode and make some
adjustments for JSX.
#+BEGIN_SRC emacs-lisp
(add-to-list 'magic-mode-alist '("^import.*React.* from 'react'" . my-jsx-hook) )
(defun my-jsx-hook ()
  "Set web mode with adjustments for JSX"
  (interactive)
  (web-mode)
  (web-mode-set-content-type "jsx")
  (setq emmet-expand-jsx-className? t)
  (emmet-mode)))
#+END_SRC
*** Vue
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode "\\.vue\\'"
  :config
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2)
  (setq web-mode-script-padding 0)
  (defun jjpandari/merge-imenu (index-fun)
    (interactive)
    (let ((mode-imenu (funcall index-fun))
          (custom-imenu (imenu--generic-function imenu-generic-expression)))
      (append custom-imenu mode-imenu)))

  (use-package prettier-js
    :config
    (add-hook 'web-mode-hook #'(lambda ()
                                 (enable-minor-mode
                                  '("\\.vue?\\'" . prettier-js-mode)))))

  (add-hook 'web-mode-hook
            (lambda ()
              (setq imenu-create-index-function (lambda () (jjpandari/merge-imenu 'web-mode-imenu-index))))))

(require 'aurayb-narrow-indirect-vue)
;; (define-key my-keys-minor-mode-map (kbd "nj") (aurayb-make-narrow-indirect-vue "script" 'js2-mode))
;; (define-key my-keys-minor-mode-map (kbd "nh") (aurayb-make-narrow-indirect-vue "template" 'html-mode))
;; (define-key my-keys-minor-mode-map (kbd "ns") (aurayb-make-narrow-indirect-vue "style" 'scss-mode))
;; (define-key my-keys-minor-mode-map (kbd "nn") '(lambda () (interactive) (pop-to-buffer-same-window (buffer-base-buffer))))
#+END_SRC
* Flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :diminish flycheck-mode
  :init
  (add-hook 'web-mode-hook 'flycheck-mode)
  (add-hook 'js2-mode-hook 'flycheck-mode)
  (add-hook 'cfn-mode-hook 'flycheck-mode)
  (add-hook 'ruby-mode-hook 'flycheck-mode)
  :config
  (define-key evil-normal-state-map (kbd "[f") 'flycheck-previous-error)
  (define-key evil-normal-state-map (kbd "]f") 'flycheck-next-error)

  (flycheck-add-mode 'javascript-eslint 'web-mode)
  (defun my/use-eslint-from-node-modules ()
    (let* ((root (locate-dominating-file
                  (or (buffer-file-name) default-directory)
                  "node_modules"))
           (eslint (and root
                        (expand-file-name "node_modules/eslint/bin/eslint.js"
                                          root))))
      (when (and eslint (file-executable-p eslint))
        (setq-local flycheck-javascript-eslint-executable eslint))))
  (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)

(define-derived-mode cfn-mode yaml-mode
  "Cloudformation"
  "Cloudformation template mode.")
(add-to-list 'auto-mode-alist '(".template.yaml\\'" . cfn-mode))
(flycheck-define-checker cfn-lint
  "A Cloudformation linter using cfn-python-lint.
            See URL 'https://github.com/awslabs/cfn-python-lint'."
  :command ("cfn-lint" "-f" "parseable" source)
  :error-patterns (
                   (warning line-start (file-name) ":" line ":" column
                            ":" (one-or-more digit) ":" (one-or-more digit) ":"
                            (id "W" (one-or-more digit)) ":" (message) line-end)
                   (error line-start (file-name) ":" line ":" column
                          ":" (one-or-more digit) ":" (one-or-more digit) ":"
                          (id "E" (one-or-more digit)) ":" (message) line-end)
                   )
  :modes (cfn-mode))
(add-to-list 'flycheck-checkers 'cfn-lint))

#+END_SRC
* Bindings
#+BEGIN_SRC emacs-lisp
(use-package evil
  :config
  (setq evil-want-C-i-jump nil)
  (evil-define-key 'insert lisp-interaction-mode-map (kbd "C-j") 'eval-print-last-sexp))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package key-chord
  :defer 2
  :after evil
  :config
  (key-chord-mode 1)
  (key-chord-define evil-insert-state-map  "jk" 'evil-normal-state))
#+END_SRC

** General
Shows a key combination helper in the minibuffer
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :diminish which-key-mode
  :config
  (which-key-mode))
#+END_SRC

~recursived-edit~, combined with C-M-c (exit-recursive-edit),
allows to stop doing something momentarily, do something else and
come back to it later.
#+BEGIN_SRC emacs-lisp
(define-key my-keys-minor-mode-map (kbd "C-M-e") 'recursive-edit)
#+END_SRC

Make grep buffers writable with ~C-c C-p~. Apply changes with ~C-c C-e~
#+BEGIN_SRC emacs-lisp
;; makes grep buffers writable and apply the changes to files.
(use-package wgrep :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package paredit
  :diminish paredit-mode
  :bind (:map my-keys-minor-mode-map
         ("C-c 0" . paredit-forward-slurp-sexp)
         ("C-c 9" . paredit-backward-slurp-sexp)
         ("C-c ]" . paredit-forward-barf-sexp)
         ("C-c [" . paredit-backward-barf-sexp))
  :config
  (add-hook 'emacs-lisp-mode-hook #'paredit-mode))

(use-package expand-region
  :bind (:map my-keys-minor-mode-map ("C-c w" . er/expand-region)))

(define-key my-keys-minor-mode-map (kbd "C-c a") 'org-agenda)
(define-key my-keys-minor-mode-map (kbd "C-c R") 'revert-buffer)
(define-key my-keys-minor-mode-map (kbd "C-c jc") 'org-clock-jump-to-current-clock)
(define-key my-keys-minor-mode-map (kbd "C-c je") '(lambda () (interactive) (find-file "~/.emacs.d/init.org")))
(define-key my-keys-minor-mode-map (kbd "C-c jp") '(lambda () (interactive) (find-file "~/projects/")))
(define-key my-keys-minor-mode-map (kbd "C-c jw") '(lambda () (interactive) (find-file "~/work")))
(define-key my-keys-minor-mode-map (kbd "C-c jg") '(lambda () (interactive) (find-file (concat **local-dropbox-folder** "/org/gtd.org"))))
(define-key my-keys-minor-mode-map (kbd "C-c js") 'slip-box)
(define-key my-keys-minor-mode-map (kbd "C-c ji") '(lambda () (interactive) (find-file (concat **local-dropbox-folder** "org/slip-box/index.org"))))
(define-key my-keys-minor-mode-map (kbd "C-c jr") '(lambda () (interactive) (find-file (concat **local-dropbox-folder** "org/references-notes"))))
(define-key my-keys-minor-mode-map (kbd "C-c jj") 'dired-jump)
(define-key my-keys-minor-mode-map (kbd "C-c k") 'recompile)
(define-key my-keys-minor-mode-map (kbd "C-c K") 'compile)

(define-key my-keys-minor-mode-map (kbd "<f5>") 'ispell-buffer)

(define-key my-keys-minor-mode-map (kbd "C-c h") 'highlight-symbol-at-point)
(define-key my-keys-minor-mode-map (kbd "C-c H") 'unhighlight-regexp)

(defun hide-line-numbers ()
  (interactive)
  (setq display-line-numbers (quote nil)))
(define-key my-keys-minor-mode-map (kbd "C-c olh") 'hide-line-numbers)

(defun show-line-numbers ()
  (interactive)
  (setq display-line-numbers (quote absolute)))
(define-key my-keys-minor-mode-map (kbd "C-c oll") 'show-line-numbers)
(define-key my-keys-minor-mode-map (kbd "C-c ow") 'visual-line-mode)
(define-key my-keys-minor-mode-map (kbd "C-c of") 'auto-fill-mode)
(global-hl-line-mode t)
(define-key my-keys-minor-mode-map (kbd "C-c og") 'global-hl-line-mode)
(define-key my-keys-minor-mode-map (kbd "C-c op") 'show-paren-mode)

(use-package rainbow-mode
  :diminish rainbow-mode
  :bind (:map my-keys-minor-mode-map
              ("C-c or" . rainbow-mode)))

(define-key my-keys-minor-mode-map (kbd "C-c ot") 'toggle-truncate-lines)

(use-package evil
  :config
   (define-key evil-normal-state-map (kbd "[b") 'previous-buffer)
   (define-key evil-normal-state-map (kbd "]b") 'next-buffer)
   (define-key evil-normal-state-map (kbd "]e") 'next-error)
   (define-key evil-normal-state-map (kbd "[e") 'previous-error))

(use-package windresize
  :bind (:map evil-normal-state-map
              ("C-w r" . windresize)))
#+END_SRC
** Drag stuff
#+BEGIN_SRC emacs-lisp
(use-package drag-stuff
  :diminish t
  :bind (:map my-keys-minor-mode-map
         ("C-M-<up>" . drag-stuff-up)
         ("C-M-<down>" . drag-stuff-down))
  :config
  (drag-stuff-global-mode t))
#+END_SRC

* Notes

Some people switch to Emacs just to use org-mode.

It is one of the best tool for note taking and writing

Setting the org-directory helps integration with org-agenda and
for org template captures.
#+BEGIN_SRC emacs-lisp
(setq org-directory **local-dropbox-folder**)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'turn-on-auto-fill)

(add-hook 'org-capture-mode-hook 'evil-insert-state)

(use-package evil
  :init
  (setq org-use-speed-commands nil) ; they don't work well with Evil.
  :config
  (evil-define-key 'normal org-mode-map
    (kbd "M-l") 'org-shiftmetaright
    (kbd "M-h") 'org-shiftmetaleft
    (kbd "M-k") 'org-move-subtree-up
    (kbd "M-j") 'org-move-subtree-down
    (kbd "M-p") 'org-publish-current-project
    (kbd "TAB") 'org-cycle)
  )

;; (add-to-list 'org-modules "org-habit")
;; (add-to-list 'org-modules "org-git-link")
(setq org-log-into-drawer t)
(define-key my-keys-minor-mode-map "\C-ci" 'counsel-org-goto)

(setq org-todo-keywords
      '((sequence "TODO" "WAITING" "|" "DONE(!)")))
#+END_SRC

** Navigate Notes
#+begin_src emacs-lisp :results silent
(use-package deft
 :bind (:map my-keys-minor-mode-map
             ("<f9>" . deft))
 :commands (deft)
 :config
 (setq deft-extensions '("org" "md")
       deft-recursive t
       deft-directory (concat **local-dropbox-folder** "org/")))
#+end_src
** References

I use ~ivy-bibtex~ to add references to my documents.
From ~ivy-bibtex~ I can access the ref note with hydra.

To add references to my reference library:
- for papers I use ~doi-add-bibtex-entry~
- for websites I use ~org-ref-url-html-to-bibtex~
- for books I use ~isbn-to-bibtex~
#+begin_src emacs-lisp :results silent :tangle yes
(setq reftex-default-bibliography `(,(concat **local-dropbox-folder** "org/references.bib")))
(use-package org-ref
  :config
  (setq org-ref-bibliography-notes (concat **local-dropbox-folder** "org/references.org")
        org-ref-default-bibliography `(,(concat **local-dropbox-folder** "org/references.bib"))
        org-ref-pdf-directory (concat **local-dropbox-folder** "org/bibtex-pdfs/"))
  (require 'org-ref-pdf)
  (require 'org-ref-url-utils)
  (require 'org-ref-isbn)
  (require 'org-ref-bibtex)
  (require 'doi-utils))

(use-package ivy-bibtex
  :bind (:map my-keys-minor-mode-map
             ("C-c B" . ivy-bibtex))
  :config
  (setq ivy-bibtex-default-action 'ivy-bibtex-insert-citation)
  (setq bibtex-completion-bibliography reftex-default-bibliography)
  (setq bibtex-completion-notes-path (concat **local-dropbox-folder** "org/references-notes/")))
#+end_src

** Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
 :mode "\\.md\\'")
#+END_SRC
** Capture Ideas

~C-c l~ to store a link and ~C-c C-l~ to insert that link.

If you have a selection, it will be part of the link and Emacs will
look for that selection If you visit the link.
#+BEGIN_SRC emacs-lisp
   (define-key my-keys-minor-mode-map "\C-cl" 'org-store-link)
#+END_SRC

~palimpsest~ makes it easier to quickly discard blocks of text.
Main use is to just send the block of text at the bottom of the
buffer. This way I can revise my writing without losing my drafts.
~C-c C-q~ move region to trash
~C-c C-r~ move region to bottom
#+BEGIN_SRC emacs-lisp
(use-package palimpsest
  :diminish palimpsest-mode
  :config
  (add-hook 'org-mode-hook 'palimpsest-mode))
#+END_SRC

org-capture allows to set up templates for quick note taking.
This is a must to capture ideas quickly.
#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      '(("n" "Notes" entry (file+headline **local-note-file** "Inbox") "* %?\n")
        ("t" "todo" entry (file+headline **local-note-file** "Inbox")
         "* TODO [#A] %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n%a\n")"))]")
      )

(define-key my-keys-minor-mode-map (kbd "C-c n") '(lambda () (interactive) (org-capture nil "n")))
(add-hook 'org-capture-mode-hook 'evil-insert-state)
#+END_SRC

To launch an Emacs client with a capture frame selecting the ~n~ template
~emacsclient -ca "" --frame-parameters='(quote (name .
"global-org-capture"))' -e '(org-capture nil "n")'~.

It works nicely on Linux, however on Mac the focus and input focus
is sketchy and is not reliable.

The following takes advantage that I name those capture frame
~global-org-capture~ to do some housekeeping around them
#+BEGIN_SRC emacs-lisp
(defadvice org-capture-finalize
    (after delete-capture-frame activate)
  "Advise capture-finalize to close the frame"
  (if (equal "global-org-capture" (frame-parameter nil 'name))
      (progn
        (delete-frame))))

(defadvice org-capture-destroy
    (after delete-capture-frame activate)
  "Advise capture-destroy to close the frame"
  (if (equal "global-org-capture" (frame-parameter nil 'name))
      (progn
        (delete-frame))))

;; make the frame contain a single window. by default org-capture
;; splits the window.
(add-hook 'org-capture-mode-hook
          'delete-other-windows)
#+END_SRC

** Inline Code

Org babel allows to evaluate code snippets inside org files.
This is the best way I know of doing [[https://en.wikipedia.org/wiki/Literate_programming][Literate Programming]]

This loads more programming languages to use with org-babel.
#+BEGIN_SRC emacs-lisp
(require 'ob-clojure) ;; run cider-jack-in from org buffer to be able to run
                      ;; clojure code
(use-package ob-clojurescript) ;; requires [[https://github.com/anmonteiro/lumo][lumo]]
(setq org-babel-clojure-backend 'cider)
(require 'ob-js)
(setq org-babel-js-function-wrapper "require('util').log(require('util').inspect(function(){%s}()));")
(org-babel-do-load-languages 'org-babel-load-languages
                             '((shell . t)
                               (ditaa . t)))
(setq org-ditaa-jar-path "/usr/local/Cellar/ditaa/0.11.0/libexec/ditaa-0.11.0-standalone.jar")
#+END_SRC

** Publish
My strategy is to keep my writings in the same folder
~$HOME/Dropbox/org/writing~ and run ~org-publish-current-file~ or
~org-publish~ to export to HTML.

To get a preview
I run ~toggle-html-export-on-save~ when i work on a particular org file.
I use ~npm install -g simple-autoreload-server~ to auto-reload files
in my browser.

I have a [[https://github.com/aurelienbottazini/dotfiles/blob/c071cf2ca49ca9a98da815f17d500980f95873da/tmux/.config/tmuxinator/blog.yml#L9][tmuxinator configuration file]] to quickly launch my blog server

#+BEGIN_SRC emacs-lisp
(setq
 time-stamp-active t
 time-stamp-line-limit 30     ; check first 30 buffer lines for Time-stamp:
 time-stamp-format "%04y-%02m-%02d") ;

(use-package writeroom-mode
  :bind (:map my-keys-minor-mode-map
              ("C-c z" . writeroom-mode)))

(use-package htmlize) ; for org html export
(setq system-time-locale "C") ; make sure time local is in english when exporting
(setq org-html-validation-link nil)
(setq org-publish-project-alist
      `(
        ("blog-files"
         :base-directory ,(concat **local-dropbox-folder** "/org/blog")
         :base-extension "org"
         :publishing-directory ,(concat **local-dropbox-folder** "/org/blog_published")
         :recursive t
         :publishing-function org-html-publish-to-html
         :headline-levels 4             ; Just the default for this project.
         :auto-preamble t
         :html-head-extra nil
         ;; :body-only nil
         )
        ;; ... add all the components here (see below)...
        ;; ("wiki" :components ("wiki-files"))
        )
      user-full-name "Aurélien Bottazini"
      org-export-with-toc t
      org-html-doctype "html5"
      org-html-head "<link rel=\"stylesheet\" type=\"text/css\" href=\"/css/main.css\" />"
      org-html-head-include-default-style nil
      org-html-head-include-scripts nil
      org-html-html5-fancy t
      org-html-postamble nil
      org-src-preserve-indentation nil
      org-html-htmlize-output-type "css"
      org-html-indent nil               ; a value other than nil will screw up src block indentation
      org-edit-src-content-indentation 0)

(add-hook 'org-mode-hook
          (lambda ()
            (setq-local time-stamp-start "Updated on[ 	]+\\\\?[\"<]+")
            (org-indent-mode t)
            (add-hook 'before-save-hook 'time-stamp nil 'local)))

(add-hook 'write-file-hooks 'time-stamp) ; update time-stamp on save
(require 'ox-publish)
(setq system-time-locale "C") ;; make sure time local is in english when exporting
(setq org-html-validation-link nil)

#+END_SRC
** Latex

[[https://emacs.stackexchange.com/questions/33010/how-to-word-wrap-within-code-blocks][How To break lines with code blocks]]
#+begin_src emacs-lisp
(add-to-list 'org-latex-packages-alist '("" "listings" nil))
(setq org-latex-listings t)
(setq org-latex-listings-options '(("breaklines" "true")
                                   ("literate" "{0}{0}{1}%
           {1}{1}{1}%
           {2}{2}{1}%
           {3}{3}{1}%
           {4}{4}{1}%
           {5}{5}{1}%
           {6}{6}{1}%
           {7}{7}{1}%
           {8}{8}{1}%
           {9}{9}{1}%
    ")))
#+end_src

** Feedback

Ispell buffer with ~F5~
Ispell word with ~z =~
#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "aspell")
(setq ispell-silently-savep t)
(setq ispell-personal-dictionary **local-personal-dictionary**)
;; Please note ispell-extra-args contains ACTUAL parameters passed to aspell
(setq ispell-extra-args '("--sug-mode=ultra" "--lang=en_US"))

(add-hook 'org-mode-hook 'turn-on-flyspell)
(eval-after-load "flyspell"
     '(diminish 'flyspell-mode))
#+END_SRC

Word definition
#+BEGIN_SRC emacs-lisp
(use-package define-word
  :bind (:map evil-normal-state-map
          ("zw" . define-word-at-point)))
#+END_SRC

Word synonyms.
#+BEGIN_SRC emacs-lisp
(use-package powerthesaurus
  :bind (:map evil-normal-state-map
          ("zs" . powerthesaurus-lookup-word-dwim)))
#+END_SRC

For most documents, aim for a score of approximately 60 to 70 for
the reading ease and 7.0 to 8.0 for the grade level.
#+BEGIN_SRC emacs-lisp
(use-package writegood-mode
 :bind (:map evil-normal-state-map
 (
         ("zgg" . writegood-mode)
         ("zgr" . writegood-reading-ease)
         ("zgl" . writegood-grade-level)
  )))
#+END_SRC

If you need additional feedback from an external service here is an
easy way to do it:
#+BEGIN_SRC emacs-lisp
(require 'browse-url) ; part of gnu emacs

(defun my-lookup-wikipedia ()
  "Look up the word under cursor in Wikipedia.
If there is a text selection (a phrase), use that.

This command switches to browser."
  (interactive)
  (let (word)
    (setq word
          (if (use-region-p)
              (buffer-substring-no-properties (region-beginning) (region-end))
            (current-word)))
    (setq word (replace-regexp-in-string " " "_" word))
    (browse-url (concat "http://en.wikipedia.org/wiki/" word))
    ;; (eww myUrl) ; emacs's own browser
    ))
#+END_SRC
* Vim
I started using Vim to help me prevent [[https://www.emacswiki.org/emacs/RepeatedStrainInjury][emacs RSI.]]
Now I am sticking with it because It makes me feel like beethoven
manipulating text :-)

Here is an awesome [[https://github.com/noctuid/evil-guide][Evil Guide]]

Quit read-only windows with Q instead of trying to register a Vim
Macro.
This is mainly to restore emacs behavior with help windows.
#+BEGIN_SRC emacs-lisp
(use-package evil
  :config
  (defun my-evil-record-macro ()
    (interactive)
    (if buffer-read-only
        (quit-window)
      (call-interactively 'evil-record-macro)))

  (with-eval-after-load 'evil-maps
    (define-key evil-normal-state-map (kbd "q") 'my-evil-record-macro)))
#+END_SRC

I use Vim keybindings everywhere except with special modes
like Magit, Dired... I setup those special modes to start with Emacs
keybindings by default.
#+begin_src emacs-lisp
(use-package evil
  :config
  (evil-set-initial-state 'deft-mode 'insert)
  (evil-set-initial-state 'dired-mode 'normal)
  (evil-set-initial-state 'magit-mode 'emacs)
  (evil-set-initial-state 'use-package-statistics 'emacs)
  (evil-set-initial-state 'xref--xref-buffer-mode 'emacs)
  (evil-set-initial-state 'term-mode 'emacs)
  (evil-set-initial-state 'ert-results-mode 'emacs))
#+end_src

Surround things with
- ~S~ in visual mode
- ~ys<text-object>~ in normal mode
  You can also change surroundings ~cs~ or delete surroundings ~ds~.
  #+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :after evil
    :config
    (global-evil-surround-mode 1))
  #+END_SRC

  Comment things with ~gc~. Comment and copy with ~gy~
  #+BEGIN_SRC emacs-lisp
  (use-package evil-commentary
    :after evil
    :diminish evil-commentary-mode
    :config
    (evil-commentary-mode))
  #+END_SRC

  Start a search from visual selection with ~*~ or ~#~ (backward).
  #+BEGIN_SRC emacs-lisp
  (use-package evil-visualstar
    :after evil
    :config
    (global-evil-visualstar-mode t))
  #+END_SRC

  Jump to matching pairs with ~%~.
  #+BEGIN_SRC emacs-lisp
  (use-package evil-matchit
    :defer 2
    :after evil
    :config
    (global-evil-matchit-mode 1))
  #+END_SRC

  Persist highlight from ~evil search~ and ~isearch~
  #+BEGIN_SRC emacs-lisp
  (use-package evil-search-highlight-persist
    :bind  (:map my-keys-minor-mode-map
                ("C-c oh" . (lambda ()
                              (interactive)
                              (hi-lock-mode -1) (evil-search-highlight-persist-remove-all))
                 )
                )
    :config
    (global-evil-search-highlight-persist t))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
  (use-package evil
    :config
    (evil-mode 1)
    (evil-ex-define-cmd "W" 'save-buffer))
  #+END_SRC

  Add text objects to select, copy things based on indentation level.
  Use it with ~vii~ and ~yii~.
  #+BEGIN_SRC emacs-lisp
  (use-package evil-indent-plus
    :after evil
    :config
    (evil-indent-plus-default-bindings))
  #+END_SRC

* Search
Searching is probably the most important thing in a code editor.
Here is how I search.

** Search in current file/buffer

I have two main way to search in a buffer:

*** Vim way
I use ~evil-search-forward~ (bound to ~/~) and
~evil-search-backward~ (bound to ~?~) as it allows me to do
powerful /vim/ combinations.

For example I do a search, then navigate through the search list
with ~n~ or ~N~. Or do a search then replace matches with ~:
%s//replacement/gc~

*** swiper
I use ~swiper-isearch~ when I am exploring the buffer or when I
want to do some search refinements or complex replacements.

From counsel it is easy to swith to occur with ~C-c C-o~. This
allows me to have a list of matches in a seperate buffer and edit
them using:
    - ~C-x C-q~
    - make the changes in the occur buffer
    - ~C-x C-s~ to save the changes

      #+BEGIN_SRC emacs-lisp
      (use-package ivy
        :diminish ivy-mode
        :bind (("C-s" . swiper-isearch)
               :map my-keys-minor-mode-map
               ("C-c v" . ivy-switch-view)
               ("C-c V" . ivy-push-view)
               :map ivy-minibuffer-map
               ("C-c C-c" . ivy-restrict-to-matches))
        :init
        (setq ivy-display-style 'fancy)
        (setq ivy-use-selectable-prompt t)
        (setq ivy-use-virtual-buffers t) ; enable bookmarks and recent-f
        (setq enable-recursive-minibuffers t)
        (setq ivy-initial-inputs-alist nil)
        (setq ivy-re-builders-alist
          '((t      . ivy--regex-plus)))
        :config
        (use-package ivy-hydra)
        (ivy-mode 1))
      #+END_SRC

** Search in visible windows
#+BEGIN_SRC emacs-lisp
(use-package avy
  :bind (:map my-keys-minor-mode-map
         ("C-c ;" . avy-goto-char-timer)))
#+END_SRC
** Search in project

~counsel-rg~ is my main way to search. Invoked with an argument, it
allows you to specify the directory and search options.
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :bind (:map my-keys-minor-mode-map ("C-c f" . counsel-rg)))
#+END_SRC

When I am investigating things, I like to see a preview of the
results as I scroll down the search results. I do it with ~C-o~ then
either ~g~ on the entry I want to preview or ~c~ to automatically
preview results as I move through the result list.

A trick I am learning is to use ~C-'~ to jump directly to a
search results.

*** When I need to narrow down my search to specific files

**** Narrowing on the file-type

Launch ~counsel-rg~ with a prefix and then I can use for example
~-tjs~ as an argument to search only inside javascript files.
~-Tjs~ searches inside files but javascript ones.

**** From Dired
~C-x d~ to launch dired . I mark the files I am interested in with
~m~. Then I can grep those files with ~A~ and do a query replace
with ~Q~.
** Search Emacs documentation

Remplacements for emacs search and completion commands.
I find the UI better.
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :bind (("M-x" . counsel-M-x)
         ("C-x C-m" . counsel-M-x)
         ("C-c C-m" . counsel-M-x)
         ("C-x C-f" . counsel-find-file)
         ("C-x b" . counsel-switch-buffer)
         ("<f1> f" . counsel-describe-function)
         ("<f1> v" . counsel-describe-variable)
         ("<f1> l" . counsel-find-library)
         ("<f2> i" . counsel-info-lookup-symbol)
         ("<f2> u" . counsel-unicode-char)
         :map minibuffer-local-map
         ("C-r" . counsel-minibuffer-history)
         :map my-keys-minor-mode-map
         ("C-c r" . counsel-buffer-or-recentf))
  :init
  (setq counsel-git-cmd "rg --files")
  (setq counsel-rg-base-command
        "rg --smart-case -M 120 --hidden --no-heading --line-number --color never %s .")

  :config
  (eval-after-load "counsel" '(progn
                                (defun counsel-imenu-categorize-functions (items)
                                  "Categorize all the functions of imenu."
                                  (let ((fns (cl-remove-if #'listp items :key #'cdr)))
                                    (if fns
                                        (nconc (cl-remove-if #'nlistp items :key #'cdr)
                                               `((":" ,@fns)))
                                      items))))))

#+END_SRC

** Rename

Bindings: https://github.com/syl20bnr/evil-iedit-state#in-iedit-state

`e` from expand region to switch to iedit state
`S` to substitute
`D` to delete
`n` next
`p` previous
`F` reduce scope to current function
`tab` toggle occurrence
#+BEGIN_SRC emacs-lisp
(use-package iedit)

(use-package evil-iedit-state
  :bind (:map my-keys-minor-mode-map ("<f6>" . evil-iedit-state/iedit-mode)))
#+END_SRC

* VCS
Don't forget Emacs vcs features accessible with the prefix ~C-x v~!

** Resolving conflicts

This is to prevent popup windows when resolving file conflicts.
I prefer to have the ediff take over and restove the windows when
done.
#+BEGIN_SRC emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
(add-hook 'ediff-after-quit-hook-internal 'winner-undo)
(setq ediff-split-window-function 'split-window-vertically)
#+END_SRC

** Working with GitHub

To grab a link I can share with co-workers from the region or file.
#+BEGIN_SRC emacs-lisp
(use-package git-link
  :bind (:map my-keys-minor-mode-map
              ("C-c gl" . git-link)))
#+END_SRC

Otherwise I launch a ~gitsh~ session and I use [[https://github.com/github/hub][hub]] to interact with
github directly

** View History
*** timemachine
Allows to view previous versions of a file. It is not focused on the
diff but on the file itself. Use ~n~ and ~p~ to navigate between
versions.
#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :bind (:map my-keys-minor-mode-map
              ("C-c gt" . git-timemachine-toggle))
  :config
  (defadvice git-timemachine-mode (after git-timemachine-change-to-emacs-state activate compile)
    "when entering git-timemachine mode, change evil normal state to emacs state"
    (if (evil-normal-state-p)
        (evil-emacs-state)
      (evil-normal-state)))

  (ad-activate 'git-timemachine-mode))
#+END_SRC
*** vc-annotate

Bound to ~C-x v g~.
- Use ~l~ to see the commit message
- ~f~ to see what the file looked like at that revision. You can
  then use /git-link/ to grab a link with ~C-c gl~
- ~n~ and ~p~ to navigate between revisions
- ~=~ to see the diff.

  I prefer to use a full-window with vc-annotate
  #+BEGIN_SRC emacs-lisp
  (use-package fullframe
    :config
    (fullframe vc-annotate quit-window))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
  (eval-after-load "vc-annotate"
       '(progn
        (define-key vc-annotate-mode-map "j" 'evil-next-line)
        (define-key vc-annotate-mode-map "k" 'evil-previous-line)))

  (use-package evil
    :config
    (evil-define-key 'normal diff-mode-map (kbd "q") 'quit-window))
  #+END_SRC

** Magit

#+BEGIN_QUOTE
[[https://magit.vc/][Magit]] is an interface to the version control system Git, implemented
as an Emacs package. Magit aspires to be a complete Git porcelain.
While we cannot (yet) claim that Magit wraps and improves upon each
and every Git command, it is complete enough to allow even
experienced Git users to perform almost all of their daily version
control tasks directly from within Emacs. While many fine Git
clients exist, only Magit and Git itself deserve to be called
porcelains.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package magit
  :demand true
  :bind (:map my-keys-minor-mode-map
              ("C-c gs" . magit-status)
              ("C-c gc" . magit-commit)
              ("C-c gp" . magit-push-current)
              ("C-c gf" . magit-file-dispatch))
  :init
  (setq magit-commit-show-diff nil
        magit-revert-buffers 1))
#+END_SRC

When I use magit, I prefer to have it use the full emacs frame
instead of splitting the current buffer.
#+BEGIN_SRC emacs-lisp
(use-package fullframe
  :after magit
  :config
  (fullframe magit-status magit-mode-quit-window))
#+END_SRC

Start in insert mode when committing from vcs
#+BEGIN_SRC emacs-lisp
(use-package evil
  :config
  (add-hook 'with-editor-mode-hook 'evil-insert-state))
#+END_SRC

** gitsh

#+BEGIN_QUOTE
The [[https://github.com/thoughtbot/gitsh][gitsh]] program is an interactive shell for git. From within
gitsh you can issue any git command, even using your local aliases
and configuration
#+END_QUOTE

When I have to do git related things that are painful to do with
magit, I just fire a terminal with /gitsh/ for the current project.

** Visual enhancements

See in the fringe lines added, changed and removed since last commit.
#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :after magit
  :config
  (add-hook 'prog-mode-hook 'diff-hl-mode)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
#+END_SRC

* Projects
Emacs is not an IDE but I can be pretty close to one.
Here are some tools I use that are IDE oriented.

** Projectile
#+begin_src emacs-lisp
(use-package projectile
:bind-keymap
("C-c p" . projectile-command-map)
:config
(projectile-mode +1))

#+end_src
** Find file in project
*** Examples
#+BEGIN_SRC emacs-lisp :tangle no
;; if the full path of current file is under SUBPROJECT1 or SUBPROJECT2
;; OR if I'm reading my personal issue track document,
(defun my-setup-develop-environment ()
  (interactive)
  (when (ffip-current-full-filename-match-pattern-p "\\(PROJECT_DIR\\|issue-track.org\\)")
    ;; Though PROJECT_DIR is team's project, I care only its sub-directory "subproj1""
    (setq-local ffip-project-root "~/projs/PROJECT_DIR/subproj1")
    ;; well, I'm not interested in concatenated BIG js file or file in dist/
    (setq-local ffip-find-options "-not -size +64k -not -iwholename '*/dist/*'")
    ;; for this project, I'm only interested in certain types of files
    (setq-local ffip-patterns '("*.html" "*.js" "*.css" "*.java" "*.xml" "*.js"))
    ;; maybe you want to search files in `bin' directory?
    (setq-local ffip-prune-patterns (delete "*/bin/*" ffip-prune-patterns))
    ;; exclude `dist/' directory
    (add-to-list 'ffip-prune-patterns "*/dist/*"))
  ;; insert more WHEN statements below this line for other projects
  )

;; most major modes inherit from prog-mode, so below line is enough
(add-hook 'prog-mode-hook 'my-setup-develop-environment)
#+END_SRC

All variables may be overridden on a per-directory basis in your
.dir-locals.el. See (info “(Emacs) Directory Variables”) for
details.

You can place .dir-locals.el into your project root directory.

A sample .dir-locals.el,

#+BEGIN_SRC emacs-lisp :tangle no
((nil . ((ffip-project-root . "~/projs/PROJECT_DIR")
         ;; ignore files bigger than 64k and directory "dist/" when searching
         (ffip-find-options . "-not -size +64k -not -iwholename '*/dist/*'")
         ;; only search files with following extensions
         (ffip-patterns . ("*.html" "*.js" "*.css" "*.java" "*.xml" "*.js"))
         (eval . (progn
                   (require 'find-file-in-project)
                   ;; ignore directory ".tox/" when searching
                   (setq ffip-prune-patterns `("*/.tox/*" ,@ffip-prune-patterns))
                   ;; Do NOT ignore directory "bin/" when searching
                   (setq ffip-prune-patterns `(delete "*/bin/*" ,@ffip-prune-patterns))))
         )))
#+END_SRC

*** My configuration

To install fd (rust replacement for find), download it
[[https://github.com/sharkdp/fd/releases][here]] and run ~sudo dpkg -i fd_7.0.0_amd64.deb~. You can then choose
to use `fd` instead of find.
#+BEGIN_SRC emacs-lisp
(use-package find-file-in-project
  :ensure t
  :bind (:map  my-keys-minor-mode-map
               ("C-c T" . find-file-in-project-by-selected)
               :map evil-normal-state-map
               ("gf" . find-file-in-project-at-point))
  :config

  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.png")) ffip-ignore-filenames))
  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.jpg")) ffip-ignore-filenames))
  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.jpeg")) ffip-ignore-filenames))
  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.gif")) ffip-ignore-filenames))
  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.bmp")) ffip-ignore-filenames))
  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.ico")) ffip-ignore-filenames))
  (setq ffip-prefer-ido-mode nil)
  (setq ffip-use-rust-fd t)
  (setq ffip-strip-file-name-regex "\\(\\.mock\\|_test\\|\\.test\\|\\.mockup\\|\\.spec\\)")
  (add-to-list 'ffip-prune-patterns "*/.git/*")
  (add-to-list 'ffip-prune-patterns "*/dist/*")
  (add-to-list 'ffip-prune-patterns "*/.emacs.d/elpa/*")
  (add-to-list 'ffip-prune-patterns "*/.nuxt/*")
  (add-to-list 'ffip-prune-patterns "*/spec/coverage/*")
  (add-to-list 'ffip-prune-patterns "*/public/*")
  (add-to-list 'ffip-prune-patterns "*/.shadow-cljs/*")
  (add-to-list 'ffip-prune-patterns "*/vendor/*")
  (add-to-list 'ffip-prune-patterns "node_modules/*"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'abott-find-in-project)
;; (define-key my-keys-minor-mode-map (kbd "C-c s") 'projectile-toggle-between-implementation-and-test)
(define-key my-keys-minor-mode-map (kbd "C-c s") 'abott-find-file-with-similar-name)
#+END_SRC

** fzf
#+BEGIN_SRC emacs-lisp
(use-package fzf
  :bind (:map  my-keys-minor-mode-map
               ("C-c t" . fzf-projectile)))
#+END_SRC

** Jump

/dumb-jump/ just do a search through the project to try to guess the
correct jump location for the current symbol. It is not has good as an
IDE code analysis but it works surprisingly well.

~M-.~ or ~gd~ to search from normal mode
~M-,~ to go back.
~M-?~ to find references
#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :init
  (setq dumb-jump-selector 'ivy)
  :config
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+END_SRC

** Tags

Tags are generated through a [[file:~/dotfiles/git/.git_template/hooks/post-commit::.git/hooks/create_ctags%20>/dev/null%202>&1%20&][git hook] with] [[https://ctags.io/][Universal ctags]].

To make sure my hooks are used I delete the hooks directory
~./git/config~ and run ~git init .~ again from the concerned project
directory.

My [[file:~/dotfiles/git/.git_template][templates]] are used thanks to the [[~GIT_TEMPLATE_DIR][~GIT_TEMPLATE_DIR~]] environment variable.
#+BEGIN_SRC shell :results output
   env | grep GIT_TEMPLATE_DIR
#+END_SRC

#+RESULTS:
: GIT_TEMPLATE_DIR=/home/auray/.git_template

I install Universal ctags with
#+BEGIN_SRC shell :results output
   brew install --HEAD universal-ctags/universal-ctags/universal-ctags
#+END_SRC

To verify you have the proper version of universal ctags run
#+BEGIN_SRC shell :results output
   ctags --version | grep -q "Universal Ctags" >/dev/null && echo "Universal ctags is installed" || echo "Missing Universal ctags"
#+END_SRC

#+RESULTS:
: Universal ctags is installed

** Navigation tree
#+begin_src emacs-lisp
 (setq speedbar-directory-unshown-regexp "^$")
 (define-key my-keys-minor-mode-map (kbd "C-c b") 'speedbar-get-focus)
#+end_src

* Completion
** Hippie expand
Bound to ~s-/~, it provides a simple on demand completion mechanism.
You can customize its behaviour by choosing different expand functions.

The description of all the hippie expand functions is inside
[[https://github.com/emacs-mirror/emacs/blob/master/lisp/hippie-exp.el#L63][~hippie-exp.el~]] (location can vary on your system)
#+BEGIN_SRC emacs-lisp
(setq hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-from-kill try-expand-all-abbrevs try-expand-list))
(require 'mode-local)
(setq-mode-local elisp-mode hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-from-kill try-expand-list try-complete-lisp-symbol-partially try-complete-lisp-symbol))
(setq-mode-local elisp-mode hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-from-kill try-expand-all-abbrevs try-complete-lisp-symbol-partially try-complete-lisp-symbol))
(define-key evil-insert-state-map (kbd "s-/") 'hippie-expand)
(define-key evil-insert-state-map (kbd "M-/") 'hippie-expand)
#+END_SRC

** Auto-Completion

company shows a popup where you can select completions with a number
or with ~enter~. You can also invoke the popup manually with ~C-x
C-o~

#+BEGIN_SRC emacs-lisp
(use-package company
  :diminish company-mode
  :config
  (setq company-idle-delay 0.2
        company-tooltip-limit 10
        company-tooltip-align-annotations t
        company-require-match 'never
        company-global-modes '(not eshell-mode comint-mode erc-mode message-mode help-mode gud-mode)
        company-frontends '(company-pseudo-tooltip-frontend company-echo-metadata-frontend)
        company-backends '((company-files company-dabbrev company-capf company-yasnippet))
        company-transformers '(company-sort-by-occurrence))

  (add-hook 'after-init-hook 'global-company-mode)
  (setq company-dabbrev-downcase nil)
  (setq company-show-numbers t)
  (define-key evil-insert-state-map (kbd "C-x C-o") 'company-complete)

  (use-package company-statistics
    :after company
    :config
    (setq company-statistics-file "~/.emacs.d/company-stats-cache.el")
    (company-statistics-mode +1))
      ;;; Prevent suggestions from being triggered automatically. In particular,
  ;;; this makes it so that:
  ;;; - TAB will always complete the current selection.
  ;;; - RET will only complete the current selection if the user has explicitly
  ;;;   interacted with Company.
  ;;; - SPC will never complete the current selection.
  ;;;
  (dolist (key '("<return>" "RET"))
    ;; Here we are using an advanced feature of define-key that lets
    ;; us pass an "extended menu item" instead of an interactive
    ;; function. Doing this allows RET to regain its usual
    ;; functionality when the user has not explicitly interacted with
    ;; Company.
    (define-key company-active-map (kbd key)
      `(menu-item nil company-complete
                  :filter ,(lambda (cmd)
                             (when (company-explicit-action-p)
                               cmd)))))
  (define-key company-active-map (kbd "TAB") #'company-complete-selection)
  (define-key company-active-map (kbd "SPC") nil)
  (autoload 'company-capf "company-capf")
  (autoload 'company-yasnippet "company-yasnippet")
  (autoload 'company-elisp "company-elisp")
  (autoload 'company-files "company-files"))
#+END_SRC

** Snippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :defer 3
  :commands yas-expand-snippet
  :bind (:map my-keys-minor-mode-map
              ("C-c y" . yas-insert-snippet))
  :diminish yas-minor-mode
  :init
  (setq yas-snippet-dirs
        '("~/.emacs.d/snippets"))
  :config
  (yas-global-mode 1)
  (add-hook 'term-mode-hook (lambda()
                              (yas-minor-mode -1))))
#+END_SRC

This allow me to automatically expand [[https://github.com/aurelienbottazini/dotfiles/blob/master/emacs/.emacs.d/templates/][templates]] into new files using
the yasnippet format. The filenames for the template are regexes.
#+BEGIN_SRC emacs-lisp :tangle no
(use-package yatemplate
  :config
  (add-hook 'find-file-hook 'auto-insert)
  (yatemplate-fill-alist))
#+END_SRC

* Files and directories
** Dired
#+BEGIN_SRC emacs-lisp
(setq ls-lisp-use-insert-directory-program t) ;same ls-lisp for Dired regardless of the platform
(setq dired-listing-switches "-alh")
;; on mac there is some weird prefixing going on for GNU Tools like ls.
;; I favor GNU ls over MacOSX default ls
(when (string-equal system-type "darwin")
  (setq insert-directory-program "gls"))

(require 'dired )
(defun my-dired-mode-setup ()
  "to be run as hook for `dired-mode'."
  (dired-hide-details-mode 1))
(add-hook 'dired-mode-hook 'my-dired-mode-setup)

(put 'dired-find-alternate-file 'disabled nil)
(setq dired-dwim-target t)
(add-hook 'dired-load-hook
          (lambda ()
            (load "dired-x")
            ;; Set dired-x global variables here.  For example:
            ;; (setq dired-guess-shell-gnutar "gtar")
            ;; (setq dired-x-hands-off-my-keys nil)
            (setq dired-recursive-copies (quote always)) ; “always” means no asking
            (setq dired-recursive-deletes (quote top)) ; “top” means ask once
            ))

(eval-after-load "dired"
  '(progn
     (define-key dired-mode-map "-" 'dired-up-directory)
     (define-key dired-mode-map (kbd "/") 'evil-search-forward)
     (define-key dired-mode-map (kbd "j") 'dired-next-line)
     (define-key dired-mode-map (kbd "k") 'dired-previous-line)
     (define-key dired-mode-map (kbd "[b") 'previous-buffer)
     (define-key dired-mode-map (kbd "]b") 'next-buffer)
     (define-key dired-mode-map (kbd "C-u") 'evil-scroll-page-up)
     (define-key dired-mode-map (kbd "C-d") 'evil-scroll-page-down)
     (evil-define-key 'normal dired-mode-map
       "gg" 'evil-goto-first-line
       "^" '(lambda () (interactive) (find-alternate-file "..")))))

(define-key package-menu-mode-map (kbd "/") 'evil-search-forward)

(use-package dired-rsync
:bind (:map dired-mode-map ("p" . dired-rsync)))
#+END_SRC

** Counsel
I redefine the standard ~C-x C-f~ to use counsel. It allows me to do
pretty cool stuff with it [[https://oremacs.com/2017/11/18/dired-occur/][thanks to ivy-occur and dired]].

#+BEGIN_QUOTE
To delete all *.elc files in the current folder do:

~C-x C-f elc$ C-c C-o tDy.~

To copy all Org files in a Git project to some directory do:

~M-x counsel-git org$ C-c C-o tC.~

To get a list of videos to watch do:

~M-x counsel-fzf mp4$ C-c C-o.~
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :bind (("C-x C-f" . counsel-find-file)))
#+END_SRC

* Email

Setup mu4e directories to match [[https://www.fastmail.com][Fastmail]]
#+begin_src emacs-lisp
(require 'mu4e)
(setq mu4e-maildir (expand-file-name "~/Maildir/fastmail"))
(setq mu4e-sent-folder "/Sent Items"
      mu4e-drafts-folder "/Drafts"
      mu4e-trash-folder "/Trash"
      mu4e-refile-folder "/Archive")
#+end_src

Run the initial indexing with mu
#+begin_src shell :tangle no
mu init --my-address=aurelien.bottazini@gmail.com --my-address=abottazini@doximity.com --my-address=abottazini@fastmail.fm --my-address=abottazini@gmail.com --my-address=aurelien.bottazzini@gmail.com --my-address=iris@bottazini.com -m ~/Maildir/fastmail
mu index
#+end_src

If you run a mu index command with the incorrect path specified, you
will have problems moving emails around inside mu.
#+BEGIN_SRC emacs-lisp
(define-key my-keys-minor-mode-map (kbd "C-c m") 'mu4e)
(setq mu4e-html2text-command "/usr/bin/w3m -T text/html")
(setq mu4e-get-mail-command "/usr/bin/mbsync -a")
(setq mu4e-update-interval 300)
(add-to-list 'load-path (expand-file-name "/usr/share/emacs/site-lisp/mu4e"))

(require 'epa-file)
(setq epa-pinentry-mode 'loopback) ; fix gpg2 encryption
(epa-file-enable)

(setq mu4e-sent-messages-behavior 'sent)

(setq mu4e-maildir-shortcuts
      '(("/INBOX" . ?i)
        ("/@next" . ?n)
        ("/@waiting" . ?w)
        ("/@maybe" . ?m)
        ("/@read" . ?r)
        ("/Archive" . ?a)
        ("/Sent Items" . ?s)
        ("/Learn Spam" . ?l)
        ("/Trash" . ?t)))

;; needed for mbsync
(setq mu4e-change-filenames-when-moving t)
(setq message-kill-buffer-on-exit t)
;; I want my format=flowed thank you very much mu4e sets up visual-line-mode and
;; also fill (M-q) to do the right thing each paragraph is a single long line;
;; at sending, emacs will add the special line continuation characters.
(setq mu4e-compose-format-flowed t)
(setq message-send-mail-function 'smtpmail-send-it
      ;; smtpmail-starttls-credentials
      ;; '(("smtp.fastmail.com" 587 nil nil))
      smtpmail-default-smtp-server "smtp.fastmail.com"
      smtpmail-smtp-server "smtp.fastmail.com"
      ;; .authinfo example
      ;; machine smtp.fastmail.com login your-email@fastmail.fm port 465 password your-password
      ;; command to encrypt authinfo, you can delete authinfo after that:
      ;; gpg --output ~/.authinfo.gpg --symmetric ~/.authinfo
      smtpmail-auth-credentials (expand-file-name "~/.authinfo")
      smtpmail-stream-type 'ssl
      smtpmail-smtp-service 465)

(setq user-full-name "Aurélien Bottazini")
(setq user-mail-address "aurelien.bottazini@gmail.com")

(setq mu4e-view-show-images t)
;; use imagemagick, if available
(when (fboundp 'imagemagick-register-types)
  (imagemagick-register-types))

(setq mail-user-agent 'mu4e-user-agent)
(use-package org-msg
  :config
  (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t"
        org-msg-startup "hidestars indent inlineimages"
        org-msg-greeting-fmt ""
        org-msg-greeting-name-limit 3
        org-msg-default-alternatives '(html text)
        org-msg-signature "

 ,#+begin_signature
 -- *Aurélien* \\\\
 ,#+end_signature")
  (org-msg-mode)
  )

#+END_SRC

Custom mu4e actions
#+begin_src emacs-lisp
(use-package s)

(defun abott-prepare-path-for-wsl-open (path)
  (s-replace " " "\\ " (s-replace "file:///" "/" path)))

(defun abott-open-with-wsl-open (path)
(shell-command-to-string
(concat "wsl-open " (abott-prepare-path-for-wsl-open path))))

(defun my-browse-url-chromium-new-app (url &optional new-window)
  "Open URL in default windows app."
  (interactive (browse-url-interactive-arg "URL: "))
  (let ((wsl-path (s-replace "file:///" "/" url)))
    (unless (string= "" (abott-open-with-wsl-open (concat "\"" url "\""))))))

(setq browse-url-browser-function 'my-browse-url-chromium-new-app)
(add-to-list 'mu4e-view-actions '("browser View" . mu4e-action-view-in-browser) t)

(defun abott-mu4e-view-open-attachment-emacs (msg attachnum)
  "Open MSG's attachment ATTACHNUM in the current emacs instance."
  (let* ((att (mu4e~view-get-attach msg attachnum))
         (index (plist-get att :index)))
    (mu4e~view-temp-action (mu4e-message-field msg :docid) index 'wsl-open)))

(add-to-list 'mu4e-view-attachment-actions '("open" . abott-mu4e-view-open-attachment-emacs) t)

;;; rewritting the mu4e handler to add wsl-open (windows subsystem for linux) handler
(defun mu4e~view-temp-handler (path what docid param)
  "Handler function for doing things with temp files (ie.,
attachments) in response to a (mu4e~proc-extract 'temp ... )."
  (cond
   ((string= what "wsl-open") (abott-open-with-wsl-open path))
   ((string= what "open-with")
    ;; 'param' will be the program to open-with
    (start-process "*mu4e-open-with-proc*" "*mu4e-open-with*" param path))
   ((string= what "pipe")
    ;; 'param' will be the pipe command, path the infile for this
    (mu4e-process-file-through-pipe path param))
   ;; if it's mu4e, it's some embedded message; 'param' may contain the docid
   ;; of the parent message.
   ((string= what "mu4e")
    ;; remember the mapping path->docid, which maps the path of the embedded
    ;; message to the docid of its parent
    (puthash path docid mu4e~path-parent-docid-map)
    (mu4e~proc-view-path path mu4e-view-show-images mu4e-decryption-policy))
   ((string= what "emacs")
    (find-file path)
    ;; make the buffer read-only since it usually does not make
    ;; sense to edit the temp buffer; use C-x C-q if you insist...
    (setq buffer-read-only t))
   ((string= what "diary")
    (icalendar-import-file path diary-file))
   ((string= what "gpg")
    (epa-import-keys path))
   (t (mu4e-error "Unsupported action %S" what))))
#+end_src

Mu contexts
#+begin_src emacs-lisp
(setq mu4e-contexts
      `(
        ,(make-mu4e-context
          :name "abott"
          :enter-func (lambda () (mu4e-message "Entering abott context"))
          :leave-func (lambda () (mu4e-message "Leaving abott context"))
          :vars '( ( user-mail-address . "aurelien.bottazini@gmail.com" )))
        ,(make-mu4e-context
          :name "Doximity"
          :enter-func (lambda () (mu4e-message "Entering doximity context"))
          :leave-func (lambda () (mu4e-message "Leaving doximity context"))
          ;; we match based on the contact-fields of the message
          :match-func (lambda (msg)
                        (when msg
                          (mu4e-message-contact-field-matches msg
                                                              :to "doximity")))
          :vars '( ( user-mail-address . "abottazini@doximity.com"  )))))

(setq mu4e-context-policy 'pick-first)

;; compose with the current context is no context matches;
;; default is to ask
(setq mu4e-compose-context-policy nil)
#+end_src
* Testing

#+begin_src emacs-lisp :results silent
(setq vc-follow-symlinks t)
(put 'magit-edit-line-commit 'disabled nil)
(put 'narrow-to-region 'disabled nil)

;; I don't want to keep the current tags table when there's another one in the directory i am visiting.
;; Let's automatically switch to the new one without asking
(setq tags-add-tables nil)
#+end_src

#+begin_src emacs-lisp :results silent
(require 'wat-mode)
#+end_src

#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :bind (:map rust-mode-map
              ("C-c C-c" . rust-run)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package engine-mode
  :bind (:map my-keys-minor-mode-map
              ("C-c d c" . engine/search-caniuse)
              ("C-c d m" . engine/search-mdn)
              ("C-c d ra" . engine/search-rails)
              ("C-c d rr" . engine/search-ruby))
  :config
  (defengine ruby "https://apidock.com/ruby/search?query=%s")
  (defengine rails "https://api.rubyonrails.org/?q=%s")
  (defengine mdn "https://developer.mozilla.org/en-US/search?q=%s")
  (defengine caniuse "https://caniuse.com/#search=%s")
  )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-key my-keys-minor-mode-map "\C-c u" 'universal-argument)
(define-key my-keys-minor-mode-map "\C-u" 'evil-scroll-up)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :demand t
  :config
  (add-to-list 'auto-mode-alist '("\\.http\\'" . restclient-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package peep-dired
  :defer t ; don't access `dired-mode-map' until `peep-dired' is loaded
  :bind (:map dired-mode-map
              ("P" . peep-dired)))
#+END_SRC

Code folding
#+BEGIN_SRC emacs-lisp :results silent
(use-package origami
  :config
  (global-origami-mode))
#+END_SRC

Use emamux to rerun the last command run in tmux pane
#+BEGIN_SRC emacs-lisp
(use-package emamux
  :config
  (define-key my-keys-minor-mode-map (kbd "C-c x") '(lambda () (interactive) (emamux:send-command "!!"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :config
  (defhydra hydra-utils (global-map "<f8>")
    "drag"
    ("j" drag-stuff-down "down")
    ("k" drag-stuff-up "up")))
#+END_SRC

#+begin_src emacs-lisp
(define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eval-buffer)
#+end_src

#+begin_src emacs-lisp
(use-package default-text-scale
  :config
  (define-key my-keys-minor-mode-map (kbd "C-=") 'default-text-scale-reset)
  (define-key my-keys-minor-mode-map (kbd "C-c =") 'default-text-scale-increase)
  (define-key my-keys-minor-mode-map (kbd "C-c +") 'default-text-scale-increase)
  (define-key my-keys-minor-mode-map (kbd "C-c -") 'default-text-scale-decrease))
#+end_src

#+begin_src emacs-lisp
(desktop-save-mode 1)
#+end_src

#+begin_src emacs-lisp
(setq initial-major-mode 'org-mode)
(setq initial-scratch-message nil)
#+end_src

Changes mode-line color depending on Evil state, if buffer is-  modified etc...
#+begin_src emacs-lisp
(add-hook 'post-command-hook '(lambda ()
  (let* (
         (default-color '("#2b2b2b" "#8fb28f" . "#f0dfaf"))
         (color (cond ((minibufferp) default-color)
                      ((evil-emacs-state-p)  '("#4c7073" "#dcdccc" . "#f0dfaf"))
                      ((evil-visual-state-p) '("#adcff1" "#4c4e56" . "#4c4e56"))
                      ((evil-insert-state-p)  '("#97d88a" "#4c4e56" . "#4c4e56"))
                      ;; ((buffer-modified-p)   '("#f79b2f" "#4c4e56" . "#4c4e56"))
                      (t default-color)))
         )
    (set-face-attribute 'mode-line nil :box `(:line-width 2 :color ,(car color)))
    (set-face-background 'mode-line (car color))
    (set-face-foreground 'mode-line-buffer-id (cddr color))
    (set-face-foreground 'mode-line (cadr color)))))
#+end_src

Make my cursor match my modeline color
#+BEGIN_SRC emacs-lisp
(use-package evil
  :config
  (setq evil-insert-state-cursor '(bar "#4c4e56")
        evil-visual-state-cursor '(box "#adcff1")
        evil-emacs-state-cursor '(box "#ffa2cb")
        evil-normal-state-cursor '(box "#bc3e44")))
#+end_src

* 24 bits emacs

Run this command to know if your Emacs display 24 bits colors.
Result should be 16777216
#+begin_src emacs-lisp :tangle no
(display-color-cells)
#+end_src

On Ubuntu 20.04 I had to [[https://github.com/aurelienbottazini/dotfiles/blob/565cfb75d84d323e472232698458167ce5a66076/home/.config/shell/exports#L89][add a TERM env variable]]
If that is not the case you probably need [[https://www.gnu.org/software/emacs/manual/html_mono/efaq.html#Colors-on-a-TTY][to setup your TERM]] manually

* PDFs

https://github.com/politza/pdf-tools looks cool. Demo here: https://www.youtube.com/watch?v=LFO2UbzbZhA
https://github.com/fuxialexander/org-pdftools
* Local variables

# Local Variables:
# eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
# End:
