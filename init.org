#+TITLE: Aurélien Bottazini's Emacs configuration
#+OPTIONS: toc:4 h:4
#+PROPERTY: header-args :results silent :tangle yes

* Faster startup
Adjusts garbage collector for faster startup.
#+begin_src emacs-lisp :results silent
;; -*- lexical-binding: t; -*-
(defvar last-file-name-handler-alist file-name-handler-alist)
(setq gc-cons-threshold 402653184
      gc-cons-percentage 0.6
      file-name-handler-alist nil)

(add-hook 'emacs-startup-hook (lambda ()
                                (setq gc-cons-threshold 16777216
                                      gc-cons-percentage 0.1
                                      file-name-handler-alist last-file-name-handler-alist)))
#+end_src

* Debug Emacs

If Emacs complains about a mismatched paren while trying to start
you can use ~check-parens~ to find the mismatched parenthesis.
#+begin_src emacs-lisp :tangle no
(check-parens)
#+end_src

Emacs tends to swallow errors.
If something is not working correctly there is a good chance you will
discover what is wrong by turning on ~toggle-debug-on-error~
#+begin_src emacs-lisp :tangle no
(toggle-debug-on-error)
#+end_src

If a command is slow you can investigate with
#+begin_src emacs-lisp :tangle no
(profiler-start)
;; run your slow command
(profiler-report)
#+end_src

* Setup

** Package library initialization
#+BEGIN_SRC emacs-lisp
(setq package-archives
      '(("melpa"       . "https://melpa.org/packages/")
        ("org"         . "https://orgmode.org/elpa/")
       ("gnu"         . "http://elpa.gnu.org/packages/")))

(use-package org)

(setq package-user-dir (concat user-emacs-directory "elpa"))

;; this tells package.el not to add those pesky customized variable settings at
;; the end of your init.el
(setq package--init-file-ensured t)

(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))

(defun require-package (package &optional min-version)
  "Ask elpa to install given PACKAGE. You can specify a MIN-VERSION for your PACKAGE."
  (unless (package-installed-p package min-version)
    (package-install package)))

(require-package 'use-package)
(require 'use-package)

(setq use-package-compute-statistics t) ;(use-package-report) to show  which package is slow to start.
(setq use-package-always-ensure t) ; Install package if it is missing
#+END_SRC

You can get the time it took for emacs to start with.
#+BEGIN_SRC emacs-lisp :tangle no
   (emacs-init-time)
#+END_SRC

Zenburn is one of the most complete theme out there. It also works
well on the terminal.
https://en.wikipedia.org/wiki/Wikipedia:Zenburn
#+BEGIN_SRC emacs-lisp
(use-package zenburn-theme
 :config
 (load-theme 'zenburn t))
#+END_SRC

It is important to load custom settings early. Those are the ones
managed by Emacs through customization menus. They can impact the
loading of other packages.
#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load custom-file)
#+END_SRC

As I work on different computers, I need slightly different
settings. Instead of embedding machine specific code through
conditionals, I use a file to load machine specifics global
variables that are used in other parts of this configuration. I have
a small convention for the names. I surround them with double stars
and the name starts with local. Ex: ~(setq **local-my-variable**
"foo/bar")~.
#+BEGIN_SRC emacs-lisp
  (if (file-exists-p "~/.emacs.d/.emacs-local")
    (load "~/.emacs.d/.emacs-local"))
#+END_SRC

I keep elisp I write, or elisp not available on melpa inside the
site-lisp directory. The files in that directory are automatically
added to the Emacs load-path.
#+BEGIN_SRC emacs-lisp
  (let ((default-directory  "~/.emacs.d/site-lisp/"))
    (normal-top-level-add-to-load-path '("."))
    (normal-top-level-add-subdirs-to-load-path))
#+END_SRC

** Local variables
Local variables are useful to customize your settings for different
projects/directories. The built in ~make-local-variable~ is
convenient in helping you create those variables.

It is annoying when I edit those local variables that they are not
picked up automatically for open buffers. Those two functions help me
with the reloading of those locals.
#+BEGIN_SRC emacs-lisp
(defun my-reload-dir-locals-for-current-buffer ()
  "Reloads dir locals for the current buffer."
  (interactive)
  (let ((enable-local-variables :all))
    (hack-dir-local-variables-non-file-buffer)))

(defun my-reload-dir-locals-for-all-buffer-in-this-directory ()
  "For every buffer with the same `default-directory` as the current buffer's, reload dir-locals."
  (interactive)
  (let ((dir default-directory))
    (dolist (buffer (buffer-list))
      (with-current-buffer buffer
        (when (equal default-directory dir))
        (my-reload-dir-locals-for-current-buffer)))))
#+END_SRC

** Better Defaults
#+begin_src emacs-lisp
(setq initial-major-mode 'org-mode)
(setq initial-scratch-message nil)
#+end_src

#+begin_src emacs-lisp
(setq vc-follow-symlinks t)
(put 'magit-edit-line-commit 'disabled nil)
(put 'narrow-to-region 'disabled nil)

(setq tags-add-tables 'nil) ; always start a new TAGS table don't ask the user
#+end_src

Enable osx clipboard in terminal
#+begin_src emacs-lisp
(setq select-enable-clipboard t)
(use-package osx-clipboard
  :diminish osx-clipboard-mode
  :config
  (osx-clipboard-mode t))
#+end_src

I like setting the path manually as other solutions like ~exec-path-from-shell~
can slow down Emacs startup if the shells scripts do too many things.

`exec-path` is used by Emacs to find executables.
`PATH` is used by Emacs when you are running a shell in Emacs.
It make things easier when the two match.
#+BEGIN_SRC emacs-lisp
(setenv "JAVA_HOME" "/Library/Java/JavaVirtualMachines/adoptopenjdk-12.0.2.jdk/Contents/Home")
(let* ((home-folder (getenv "HOME"))
      (my-paths `("/home/linuxbrew/.linuxbrew/bin/"
                  ,(concat home-folder "/.config/yarn/global/node_modules/.bin/")
                  ,(concat home-folder "/.local/share/n/bin")
                  ,(concat home-folder "/work/dox-compose/bin/")
                  ,(concat home-folder "/.rbenv/bin/")
                  ,(concat home-folder "/.rbenv/shims/")
                  ,(concat home-folder "/dotfiles/bin/")
                  ,(concat home-folder "/.fzf/bin")
                  ,(concat home-folder "/.local/bin")
                  ,(concat home-folder "/.local/share/npm/bin/")
                  ,(concat home-folder "/bin")
                  "/snap/bin"
                  "/usr/local/bin"
                  "/bin/"
                  "/usr/local/sbin/"
                  "/usr/bin/"))
      )
  (setenv "PATH" (mapconcat 'identity my-paths ":" ))
  (setq exec-path my-paths))
#+END_SRC

Emacs can be really fast with large files too. The trick is to
stick to fundamental mode and disable expensive minor modes.
#+BEGIN_SRC emacs-lisp
(defun check-large-file-hook ()
  "If a file is over a given size, turn off minor modes."
  (when (> (buffer-size) (* 1024 100)) ; 100K
    (fundamental-mode)
    (font-lock-mode -1)
    (setq buffer-read-only t)
    (buffer-disable-undo)))
(add-hook 'find-file-hooks 'check-large-file-hook)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq help-window-select t ; if an help window appears, give it focus
      inhibit-startup-message t
      default-indicate-empty-lines nil ; show end of buffer on left fringe
      tab-always-indent 'complete ; try to indent first, if already indented try to complete
      )

(make-variable-buffer-local 'compile-command) ; makes the compile command be buffer specific.
(defalias 'yes-or-no-p 'y-or-n-p) ; instead of typing yes or no, type y or n
(setq ring-bell-function 'ignore) ; please don't startle me with a bell!

(setq backup-by-copying t      ; don't clobber symlinks
      backup-directory-alist
      '((".*" . "~/.local/share/emacs-saves"))    ; don't litter my fs tree
      delete-old-versions t
      kept-new-versions 6
      kept-old-versions 2
      delete-by-moving-to-trash t
      auto-save-default t ;files starting with # are generated by autosave
      auto-save-timeout 60 ; number of seconds before auto-saving
      auto-save-interval 200 ; number of keystrokes before auto-saves
      version-control t ; use versioned backups
      create-lockfiles nil
      auto-save-file-name-transforms `((".*" ,"~/.local/share/emacs-saves" t))
)

(setq global-auto-revert-non-file-buffers t) ; also auto-revert dired buffers and other special buffers

;; if file has no change, just load any changes
;; coming from an external process
(global-auto-revert-mode 1)

;; replace selected text when typing.
(pending-delete-mode 1)

(prefer-coding-system 'utf-8)
(modify-coding-system-alist 'process "\\*compilation\\*\\'"   'utf-8)

(set-default 'truncate-lines t) ; gives each line only one visual line and don't show a continuation on next line
#+END_SRC

Sentences end with one space after point. The default two space is
an historical setting. This makes Emacs sentence based commands follow
the modern standard.
#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

I want error highlights and error bindings in shell modes too.
#+BEGIN_SRC emacs-lisp
(add-hook 'shell-mode-hook 'compilation-shell-minor-mode)
#+END_SRC

*** tabs and white-space
By default I disable tabs. I use ~whitespace-mode~ in programming
buffers because sometimes when copy pasting code from external
sources those external sources have tabs. I want to see those tabs
to remove them.

I don't use the ~global-whitespace-mode~ as some emacs mode like
~magit~ use tabs.

You can remove all tabs from your buffer with ~untabify~

#+BEGIN_SRC emacs-lisp
(setq-default
 indent-tabs-mode nil    ; no tabs
 c-basic-offset 2)
#+END_SRC

Makes trailing white space and tabs visible.
#+BEGIN_SRC emacs-lisp
(setq-default whitespace-style '(face trailing tabs tab-mark))
#+END_SRC

Clean white space on save.
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
(add-hook 'prog-mode-hook 'whitespace-mode)
(eval-after-load "whitespace"
  '(diminish 'whitespace-mode))
#+END_SRC

*** Recent files
#+BEGIN_SRC emacs-lisp
(recentf-mode 1)
(setq recentf-max-menu-items 200)
(setq recentf-max-saved-items 200)
#+END_SRC

* Utility functions

#+BEGIN_SRC emacs-lisp
(defun sudo ()
  "Use TRAMP to `sudo' the file for current buffer."
  (interactive)
  (when buffer-file-name
    (find-alternate-file
     (concat "/sudo:root@localhost:"
             buffer-file-name))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun enable-minor-mode (my-pair)
  "Enable minor mode if filename match the regexp. MY-PAIR is a
cons cell (regexp . minor-mode)."
  (if (buffer-file-name)
      (if (string-match (car my-pair) buffer-file-name)
          (funcall (cdr my-pair)))))

(defun filepath-with-line-number-for-current-buffer ()
  "Return a string with Buffer-file-name:line-number.
             Make it easier to prepare commands for tools like rspec"
  (interactive)
  (concat (buffer-file-name) ":" (number-to-string (line-number-at-pos))))

(defun abott/today ()
  "Today's date as a string."
  (format-time-string "%Y-%m-%d"))

(defun add-date-to-filename ()
  "Add current date in front of filename for current buffer. This is useful with some
        Blog tools like Jekyll to publish new articles."
  (interactive)
  (let* ((date (abott/today))
         (buffer-file (buffer-file-name))
         (new-file-name (concat (file-name-directory buffer-file)
                                date
                                "-"
                                (file-name-nondirectory buffer-file)))
         )
    (rename-file buffer-file new-file-name)
    (set-visited-file-name new-file-name)
    (save-buffer)))

(defun abott/insert-date ()
  "Insert today's date in current buffer"
  (interactive)
  (insert (abott/today)))

(defun toggle-html-export-on-save ()
  "Enable or disable HTML export when saving current org buffer."
  (interactive)
  (when (not (eq major-mode 'org-mode))
    (error "Not an org-mode file!"))
  (if (memq 'org-html-export-to-html after-save-hook)
      (progn (remove-hook 'after-save-hook 'org-html-export-to-html t)
             (message "Disabled org html export on save"))
    (add-hook 'after-save-hook 'org-publish-current-file nil t)
    (set-buffer-modified-p t)
    (message "Enabled org html export on save")))


(defun abo-jump-to-note-file ()
  "Jump to org note file for current buffer"
  (interactive)
  (find-file **local-note-file**))
(global-set-key "\C-cn" 'abo-jump-to-note-file)

(defun abo-change-line-endings-to-unix ()
  (let ((coding-str (symbol-name buffer-file-coding-system)))
    (when (string-match "-\\(?:dos\\|mac\\)$" coding-str)
      (set-buffer-file-coding-system 'unix))))
#+END_SRC

* GUI

Enable ligatures on mac
#+begin_src emacs-lisp
(if (fboundp 'mac-auto-operator-composition-mode)
  (mac-auto-operator-composition-mode t))
#+end_src

#+BEGIN_SRC emacs-lisp
(blink-cursor-mode 0)
(column-number-mode) ; column number in the mode line

(electric-indent-mode t)
(global-set-key (kbd "C-c oi") 'electric-indent-mode)

(electric-pair-mode t)
(defun inhibit-electric-pair-mode-in-minibuffer (char)
  (minibufferp))
(setq electric-pair-inhibit-predicate #'inhibit-electric-pair-mode-in-minibuffer)

(setq frame-title-format "emacs")

;; makes fringe big enough with HDPI
(when (boundp 'fringe-mode)
  (fringe-mode 20))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package diminish
  :config
  (eval-after-load "undo-tree"
    '(diminish 'undo-tree-mode))
    (eval-after-load "subword"
    '(diminish 'subword-mode))
  (diminish 'auto-fill-function)
  (diminish 'eldoc-mode))
#+END_SRC

#+begin_src emacs-lisp
(setq blink-matching-paren 'jump-offscreen)
(show-paren-mode 1)

(use-package rainbow-delimiters
  :config
  (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+end_src

** Text size
Changes the size of the text. Useful when I pair program
#+begin_src emacs-lisp
  (use-package default-text-scale
    :config
    :bind (("C-=" . 'default-text-scale-reset)
           ("C-+" . 'default-text-scale-increase)
           ("C-M-+" . 'default-text-scale-decrease)))
#+end_src

Emacs makes it hard to select font with weight of Regular or Book.
The trick is to just install the font weight you want and omit the medium and
light weights. Medium and Light conflict with the Regular and Book versions
#+begin_src emacs-lisp
(setq default-frame-alist '((font . "PragmataPro Liga-16")))
#+end_src

** Code Folding
=set-selective-display=

* Regex

~C-c C-w~ to copy regex
~C-c C-q~ to quit re-builder and to remove highlights
#+BEGIN_SRC emacs-lisp
(require 're-builder)
(setq reb-re-syntax 'string)
#+END_SRC
* Org
#+begin_src emacs-lisp
(setq org-refile-targets '((nil :maxlevel . 3)
                                (org-agenda-files :maxlevel . 3)))
(advice-add 'org-refile :after
        (lambda (&rest _)
        (org-save-all-org-buffers)))
#+end_src

#+begin_src emacs-lisp
(use-package evil
  :init
  (setq org-use-speed-commands nil) ; they don't work well with Evil.
  :config
  (evil-define-key 'normal org-mode-map
    (kbd "M-l") 'org-shiftmetaright
    (kbd "M-h") 'org-shiftmetaleft
    (kbd "M-k") 'org-move-subtree-up
    (kbd "M-j") 'org-move-subtree-down
    ;; (kbd "M-p") 'org-publish-current-project
    (kbd "TAB") 'org-cycle)
  )
#+end_src

* Windows
Splitting can be done with ~C-x 2~ and ~C-x 3~  or with
~C-w v~ and ~C-w s~ to split vertically and horizontally.
* Programming languages

Auto-fill comments in prog modes
#+BEGIN_SRC emacs-lisp
(defun my-prog-mode-auto-fill-hook ()
  (setq fill-column 100)
  (set (make-local-variable 'comment-auto-fill-only-comments) t)
  (auto-fill-mode t))
(add-hook 'prog-mode-hook 'my-prog-mode-auto-fill-hook)
#+END_SRC

** Clojure
#+BEGIN_SRC emacs-lisp
;; First install the package:
(use-package flycheck-clj-kondo
  :ensure t)

(use-package clojure-mode
  :mode "\\.clj\\'"
  :config
  (require 'flycheck-clj-kondo)
  (add-hook 'clojure-mode-hook #'subword-mode))

(use-package cider
  :after clojure-mode
  :config

  (setq cider-repl-display-help-banner nil)
  )
#+END_SRC
** Ruby
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :mode "\\.ya?ml\\'")

(use-package ruby-mode
  :mode "\\.rake\\'"
  :mode "Rakefile\\'"
  :mode "\\.gemspec\\'"
  :mode "\\.ru\\'"
  :mode "Gemfile\\'"
  :mode "Guardfile\\'"
  :mode "Capfile\\'"
  :mode "\\.cap\\'"
  :mode "\\.thor\\'"
  :mode "\\.rabl\\'"
  :mode "Thorfile\\'"
  :mode "Vagrantfile\\'"
  :mode "\\.jbuilder\\'"
  :mode "Podfile\\'"
  :mode "\\.podspec\\'"
  :mode "Puppetfile\\'"
  :mode "Berksfile\\'"
  :mode "Appraisals\\'"
  :mode "\\.rb$"
  :mode "ruby"
  :config

  (add-hook 'ruby-mode-hook 'subword-mode)

  (define-key ruby-mode-map (kbd "C-c C-c") 'xmp)
  (use-package ruby-interpolation
    :diminish ruby-interpolation-mode)
  (use-package ruby-end
    :diminish ruby-end-mode
    :config
    (defun ruby-end-insert-end ()
      "Closes block by inserting end."
      (save-excursion
        (newline)
        (insert "end")
        (indent-according-to-mode)))
    )
  (use-package rspec-mode))
#+END_SRC

I learned about this on [[http://www.virtuouscode.com/2013/06/24/rubytapas-freebie-xmpfilter/][Ruby Tapas.]] Hit ~M-;~ twice adds a special
comment for xmpfilter. Running ~xmp~ will evaluate the line and put
the result after the comment. By default it does not work with Ruby
enhanced mode so I made a fix for that.
#+BEGIN_SRC emacs-lisp
(require 'rcodetools)
(defadvice comment-dwim (around rct-hack activate)
    "If comment-dwim is successively called, add => mark."
    (if (and (or (eq major-mode 'enh-ruby-mode)
                 (eq major-mode 'ruby-mode))
             (eq last-command 'comment-dwim))
        (progn
          (if (eq major-mode 'enh-ruby-mode)
              (end-of-line))
          (insert "=>"))
      ad-do-it))
#+END_SRC
** Go

#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :mode "\\.go\\'")
#+END_SRC

** HTML

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode "\\.html\\'"
  :mode "\\.gohtml\\'"
  :config
  (setq web-mode-enable-auto-closing t))

(use-package emmet-mode
  :hook (css-mode sgml-mode web-mode)
  :diminish emmet-mode
  :config
  (add-hook 'css-mode-hook
            (lambda ()
              (emmet-mode)
              (setq emmet-expand-jsx-className? nil)))

  (add-hook 'sgml-mode-hook
            (lambda ()
              (emmet-mode)
              (setq emmet-expand-jsx-className? nil))))
#+END_SRC

** CSS
#+BEGIN_SRC emacs-lisp
(use-package scss-mode :mode "\\.scss\\'")
(use-package sass-mode :mode "\\.sass\\'")
(use-package less-css-mode :mode "\\.less\\'")
#+END_SRC
** JavaScript
Node compilation errors messages are not understood by Emacs by
default. All that's needed to make it work is to add a new regex
describing what are the components of the messages.
After running the compile command, you can navigate through the
errors with ~next-error~ and ~previous-error~
#+BEGIN_SRC emacs-lisp
(require 'compile)
(setq compilation-error-regexp-alist-alist
      (cons '(node "^\\([a-zA-Z\.0-9\/-]+\\):\\([0-9]+\\)$"
                   1 ;; file
                   2 ;; line
                   )
            compilation-error-regexp-alist-alist))
(setq compilation-error-regexp-alist
      (cons 'node compilation-error-regexp-alist))

(add-hook 'js2-mode-hook
          (lambda ()
            (set (make-local-variable 'compile-command)
                 (format "node %s" (file-name-nondirectory buffer-file-name)))))

#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq js-indent-level 2)

(use-package js2-mode
  :mode "\\.js\\'"
  :mode "\\.jsx\\'"
  :config
  (setq js2-mode-show-parse-errors nil
        js2-mode-show-strict-warnings nil
        js2-basic-offset 2
        js2-highlight-level 3
        css-indent-offset 2
        web-mode-markup-indent-offset 2
        web-mode-script-padding 0
        web-mode-css-indent-offset 2
        web-mode-style-padding 2
        web-mode-code-indent-offset 2
        web-mode-attr-indent-offset 2)
  :config
  (define-key js2-mode-map (kbd "M-.") 'xref-find-definitions)
  (add-hook 'js2-mode-hook 'js2-imenu-extras-mode))
  (add-hook 'js2-mode-hook (lambda() (subword-mode t)))

(use-package json-mode
  :mode "\\.json\\'"
  :mode "\\.eslintrc\\'")

(use-package coffee-mode
  :mode "\\.coffee\\'"
  :config
  (use-package highlight-indentation)
  (add-hook 'coffee-mode-hook (lambda () (highlight-indentation-mode)))
  (add-hook 'coffee-mode-hook (lambda () (subword-mode +1)))
  (custom-set-variables '(coffee-tab-width 2)))

(use-package typescript-mode
  :mode "\\.ts\\'")
#+END_SRC

Auto-format JavaScript on save
#+BEGIN_SRC emacs-lisp
   (use-package prettier-js
     :diminish prettier-js-mode
     :config
     (setq prettier-args '(
                           "--trailing-comma" "es5"
                           "--single-quote" "true"
                           )
           prettier-js-command "prettier")
     (add-hook 'js2-mode-hook #'js2-imenu-extras-mode))
#+END_SRC

#+begin_src emacs-lisp
(defun eslint-fix-file ()
  (interactive)
  (message "eslint --fixing the file errors (not warning)" (buffer-file-name))
  (shell-command (concat "eslint --quiet --fix " (buffer-file-name))))
(defun eslint-fix-file-and-revert ()
  (interactive)
  (eslint-fix-file)
  (revert-buffer t t))
(add-hook 'js2-mode-hook
          (lambda ()
            (add-hook 'after-save-hook #'eslint-fix-file-and-revert nil 'make-it-local)))
#+end_src


Context-coloring highlights code based on closures.
This gives a refreshing view of the code and helps using closures
efficiently.
#+BEGIN_SRC emacs-lisp
(use-package context-coloring
  :ensure t
  :diminish context-coloring-mode
  :bind (("C-c oc" . context-coloring-mode))
  :config
  (add-hook 'js2-mode-hook 'context-coloring-mode))
#+END_SRC

*** React

The following shows an interesting way to quickly create
major modes _magically_. It parses the file to detect if this is a
react file. If yes I run a function to use web-mode and make some
adjustments for JSX.
#+BEGIN_SRC emacs-lisp
(add-to-list 'magic-mode-alist '("^import.*React.* from 'react'" . my-jsx-hook) )
(defun my-jsx-hook ()
  "Set web mode with adjustments for JSX"
  (interactive)
  (web-mode)
  (web-mode-set-content-type "jsx")
  (setq emmet-expand-jsx-className? t)
  (emmet-mode))
#+END_SRC
*** Vue
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode "\\.vue\\'"
  :config
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2)
  (setq web-mode-script-padding 0)
  (defun jjpandari/merge-imenu (index-fun)
    (interactive)
    (let ((mode-imenu (funcall index-fun))
          (custom-imenu (imenu--generic-function imenu-generic-expression)))
      (append custom-imenu mode-imenu)))

  (use-package prettier-js
    :config
    (add-hook 'web-mode-hook (lambda ()
                                 (enable-minor-mode
                                  '("\\.vue?\\'" . prettier-js-mode)))))

  (add-hook 'web-mode-hook
            (lambda ()
              (setq imenu-create-index-function (lambda () (jjpandari/merge-imenu 'web-mode-imenu-index))))))

(require 'aurayb-narrow-indirect-vue)
#+END_SRC
** Rust
#+BEGIN_SRC emacs-lisp
(use-package rust-mode
  :bind (:map rust-mode-map
              ("C-c C-c" . rust-run)))
#+END_SRC
** WASM
#+begin_src emacs-lisp :results silent
(require 'wat-mode)
#+end_src
** Shell
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\aliases\\'" . shell-script-mode))
(add-to-list 'auto-mode-alist '("\\exports\\'" . shell-script-mode))
#+end_src

** Lisp
#+begin_src emacs-lisp
(define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eval-buffer)
#+end_src

* Flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :diminish flycheck-mode
  :init
  (add-hook 'web-mode-hook 'flycheck-mode)
  (add-hook 'js2-mode-hook 'flycheck-mode)
  (add-hook 'cfn-mode-hook 'flycheck-mode)
  (add-hook 'ruby-mode-hook 'flycheck-mode)
  :config
  (flycheck-add-mode 'javascript-eslint 'web-mode)
  (defun my/use-eslint-from-node-modules ()
    "Find eslint in the closest node-modules folder"
    (let* ((root (locate-dominating-file
                  (or (buffer-file-name) default-directory)
                  "node_modules"))
           (eslint (and root
                        (expand-file-name "node_modules/eslint/bin/eslint.js"
                                          root))))
      (when (and eslint (file-executable-p eslint))
        (setq-local flycheck-javascript-eslint-executable eslint))))
  (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)

(define-derived-mode cfn-mode yaml-mode
  "Cloudformation"
  "Cloudformation template mode.")
(add-to-list 'auto-mode-alist '(".template.yaml\\'" . cfn-mode))
(flycheck-define-checker cfn-lint
  "A Cloudformation linter using cfn-python-lint.
            See URL 'https://github.com/awslabs/cfn-python-lint'."
  :command ("cfn-lint" "-f" "parseable" source)
  :error-patterns (
                   (warning line-start (file-name) ":" line ":" column
                            ":" (one-or-more digit) ":" (one-or-more digit) ":"
                            (id "W" (one-or-more digit)) ":" (message) line-end)
                   (error line-start (file-name) ":" line ":" column
                          ":" (one-or-more digit) ":" (one-or-more digit) ":"
                          (id "E" (one-or-more digit)) ":" (message) line-end)
                   )
  :modes (cfn-mode))
(add-to-list 'flycheck-checkers 'cfn-lint))

#+END_SRC
* Bindings

** General
Shows a key combination helper in the minibuffer
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :diminish which-key-mode
  :config
  (which-key-mode))
#+END_SRC

Make grep buffers writable with ~C-c C-p~. Apply changes with ~C-c C-e~
#+BEGIN_SRC emacs-lisp
;; makes grep buffers writable and apply the changes to files.
(use-package wgrep :defer t)
#+END_SRC

Another =M-x= without leaving the home row
#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-m") 'execute-extended-command)
#+end_src

#+BEGIN_SRC emacs-lisp
   (use-package paredit
     :diminish paredit-mode
     :config
     (add-hook 'emacs-lisp-mode-hook #'paredit-mode))

   (use-package expand-region
     :bind (("M-e" . er/expand-region)))

   (global-set-key (kbd "C-c a") 'org-agenda)
   (global-set-key (kbd "C-c R") 'revert-buffer)
   (global-set-key (kbd "C-c jc") 'org-clock-jump-to-current-clock)
   (global-set-key (kbd "C-c je") (lambda () (interactive) (find-file "~/.emacs.d/init.org")))
   (global-set-key (kbd "C-c jp") (lambda () (interactive) (find-file "~/projects/")))
   (global-set-key (kbd "C-c jw") (lambda () (interactive) (find-file "~/work")))
   (global-set-key (kbd "C-c jn") (lambda () (interactive) (find-file (concat **local-dropbox-folder** "/org/notes.org"))))
   (global-set-key (kbd "C-c jr") (lambda () (interactive) (find-file (concat **local-dropbox-folder** "org/references-notes"))))
   (global-set-key (kbd "C-c jj") 'dired-jump)
   (global-set-key (kbd "C-c k") 'recompile)
   (global-set-key (kbd "C-c K") 'compile)

   (global-set-key (kbd "<f5>") 'ispell-buffer)
   (global-set-key (kbd "C-c h") 'highlight-symbol-at-point)
   (global-set-key (kbd "C-c H") 'unhighlight-regexp)

   (defun hide-line-numbers ()
     (interactive)
     (setq display-line-numbers (quote nil)))
   (global-set-key (kbd "C-c olh") 'hide-line-numbers)

   (defun show-line-numbers ()
     (interactive)
     (setq display-line-numbers (quote absolute)))
   (global-set-key (kbd "C-c oll") 'show-line-numbers)
   (global-set-key (kbd "C-c ow") 'visual-line-mode)
   (global-set-key (kbd "C-c of") 'auto-fill-mode)
   (global-hl-line-mode t)
   (global-set-key (kbd "C-c og") 'global-hl-line-mode)
   (global-set-key (kbd "C-c op") 'show-paren-mode)

   (use-package rainbow-mode
     :diminish rainbow-mode
     :bind (("C-c or" . rainbow-mode)))

  (global-set-key (kbd "C-c ot") 'toggle-truncate-lines)

   (use-package windresize
     :bind (("C-c o h" . windresize)))
#+END_SRC
** Hydra
#+BEGIN_SRC emacs-lisp
(use-package hydra
  :config
  (defhydra hydra-utils (global-map "<f8>")
    "drag"
    ("j" drag-stuff-down "down")
    ("k" drag-stuff-up "up")))
#+END_SRC

** Drag stuff
#+BEGIN_SRC emacs-lisp
(use-package drag-stuff
  :diminish t
  :bind (("C-M-<up>" . drag-stuff-up)
         ("C-M-<down>" . drag-stuff-down))
  :config
  (drag-stuff-global-mode t))
#+END_SRC

* Notes

Some people switch to Emacs just to use org-mode.

It is one of the best tool for note taking and writing

Setting the org-directory helps integration with org-agenda and
for org template captures.
#+BEGIN_SRC emacs-lisp
(setq org-directory **local-dropbox-folder**)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'turn-on-auto-fill)

;; (require 'org-habit)
;; (add-to-list 'org-modules "org-habit")
;; (add-to-list 'org-modules "org-git-link")
(setq org-log-into-drawer t)

(setq org-todo-keywords
      '((sequence "TODO(t)" "STARTED(s!)" "WAITING(w@/!)" "|" "DONE(d!)" "CANCELED(canceled@)")))
#+END_SRC

** Navigate Notes
#+begin_src emacs-lisp :results silent
(use-package deft
 :bind (("<f9>" . deft))
 :commands (deft)
 :init
 (setq deft-extensions '("org" "md")
       deft-recursive t
       deft-directory (concat **local-dropbox-folder** "org/")))
#+end_src
** Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
 :mode "\\.md\\'")
#+END_SRC
** Capture Ideas

~C-c l~ to store a link and ~C-c C-l~ to insert that link.

If you have a selection, it will be part of the link and Emacs will
look for that selection If you visit the link.
#+BEGIN_SRC emacs-lisp
   (global-set-key "\C-cl" 'org-store-link)
#+END_SRC

~palimpsest~ makes it easier to quickly discard blocks of text.
Main use is to just send the block of text at the bottom of the
buffer. This way I can revise my writing without losing my drafts.
~C-c C-q~ move region to trash
~C-c C-r~ move region to bottom
#+BEGIN_SRC emacs-lisp
(use-package palimpsest
  :diminish palimpsest-mode
  :config
  (add-hook 'org-mode-hook 'palimpsest-mode))
#+END_SRC

org-capture allows to set up templates for quick note taking.
This is a must to capture ideas quickly.
#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      '(("n" "Notes" entry (file+headline **local-note-file** "Inbox") "* %?\n")
        ("t" "todo" entry (file+headline **local-note-file** "Inbox")
         "* TODO [#A] %?\nSCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))\n%a\n"))
      )

(global-set-key (kbd "C-c n") (lambda () (interactive) (org-capture nil "n")))
#+END_SRC

To launch an Emacs client with a capture frame selecting the ~n~ template
~emacsclient -ca "" --frame-parameters='(quote (name .
"global-org-capture"))' -e '(org-capture nil "n")'~.

It works nicely on Linux, however on Mac the focus and input focus
is sketchy and is not reliable.

The following takes advantage that I name those capture frame
~global-org-capture~ to do some housekeeping around them
#+BEGIN_SRC emacs-lisp
(defadvice org-capture-finalize
    (after delete-capture-frame activate)
  "Advise capture-finalize to close the frame"
  (if (equal "global-org-capture" (frame-parameter nil 'name))
      (progn
        (delete-frame))))

(defadvice org-capture-destroy
    (after delete-capture-frame activate)
  "Advise capture-destroy to close the frame"
  (if (equal "global-org-capture" (frame-parameter nil 'name))
      (progn
        (delete-frame))))

;; make the frame contain a single window. by default org-capture
;; splits the window.
(add-hook 'org-capture-mode-hook
          'delete-other-windows)
#+END_SRC

** Inline Code

Org babel allows to evaluate code snippets inside org files.
This is the best way I know of doing [[https://en.wikipedia.org/wiki/Literate_programming][Literate Programming]]

This loads more programming languages to use with org-babel.
#+BEGIN_SRC emacs-lisp
(require 'ob-clojure) ;; run cider-jack-in from org buffer to be able to run
                      ;; clojure code
(use-package ob-clojurescript) ;; requires [[https://github.com/anmonteiro/lumo][lumo]]
(setq org-babel-clojure-backend 'cider)
(require 'ob-js)
(setq org-babel-js-function-wrapper "require('util').log(require('util').inspect(function(){%s}()));")
(org-babel-do-load-languages 'org-babel-load-languages
                             '((shell . t)
                               (ditaa . t)))
(setq org-ditaa-jar-path "/usr/local/Cellar/ditaa/0.11.0/libexec/ditaa-0.11.0-standalone.jar")

(use-package ob-graphql)
#+END_SRC

** Publish
My strategy is to keep my writings in the same folder
~$HOME/Dropbox/org/writing~ and run ~org-publish-current-file~ or
~org-publish~ to export to HTML.

To get a preview
I run ~toggle-html-export-on-save~ when i work on a particular org file.
I use ~npm install -g simple-autoreload-server~ to auto-reload files
in my browser.

I have a [[https://github.com/aurelienbottazini/dotfiles/blob/c071cf2ca49ca9a98da815f17d500980f95873da/tmux/.config/tmuxinator/blog.yml#L9][tmuxinator configuration file]] to quickly launch my blog server

#+BEGIN_SRC emacs-lisp
(setq
 time-stamp-active t
 time-stamp-line-limit 30     ; check first 30 buffer lines for Time-stamp:
 time-stamp-format "%04y-%02m-%02d") ;

(use-package writeroom-mode
  :bind (("C-c w w" . writeroom-mode)))

(use-package htmlize) ; for org html export
(setq system-time-locale "C") ; make sure time local is in english when exporting
(setq org-html-validation-link nil)
(setq org-publish-project-alist
      `(
        ("blog-files"
         :base-directory ,(concat **local-dropbox-folder** "/org/blog")
         :base-extension "org"
         :publishing-directory ,(concat **local-dropbox-folder** "/org/blog_published")
         :recursive t
         :publishing-function org-html-publish-to-html
         :headline-levels 4             ; Just the default for this project.
         :auto-preamble t
         :html-head-extra nil
         ;; :body-only nil
         )
        ;; ... add all the components here (see below)...
        ;; ("wiki" :components ("wiki-files"))
        )
      user-full-name "Aurélien Bottazini"
      org-export-with-toc t
      org-html-doctype "html5"
      org-html-head "<link rel=\"stylesheet\" type=\"text/css\" href=\"/css/main.css\" />"
      org-html-head-include-default-style nil
      org-html-head-include-scripts nil
      org-html-html5-fancy t
      org-html-postamble nil
      org-src-preserve-indentation nil
      org-html-htmlize-output-type "css"
      org-html-indent nil               ; a value other than nil will screw up src block indentation
      org-edit-src-content-indentation 0)

(add-hook 'org-mode-hook
          (lambda ()
            (setq-local time-stamp-start "Updated on[ 	]+\\\\?[\"<]+")
            (org-indent-mode t)
            (add-hook 'before-save-hook 'time-stamp nil 'local)))

(add-hook 'write-file-hooks 'time-stamp) ; update time-stamp on save
(require 'ox-publish)
(setq system-time-locale "C") ;; make sure time local is in english when exporting
(setq org-html-validation-link nil)

#+END_SRC
** Latex

[[https://emacs.stackexchange.com/questions/33010/how-to-word-wrap-within-code-blocks][How To break lines with code blocks]]
#+begin_src emacs-lisp
(add-to-list 'org-latex-packages-alist '("" "listings" nil))
(setq org-latex-listings t)
(setq org-latex-listings-options '(("breaklines" "true")
                                   ("literate" "{0}{0}{1}%
           {1}{1}{1}%
           {2}{2}{1}%
           {3}{3}{1}%
           {4}{4}{1}%
           {5}{5}{1}%
           {6}{6}{1}%
           {7}{7}{1}%
           {8}{8}{1}%
           {9}{9}{1}%
    ")))
#+end_src

** Feedback

Ispell buffer with ~F5~
Ispell word with ~z =~

Requires to install =hunspell= and =hunspell-fr=
#+begin_src shell :tangle no :dir  /sudo::
apt install hunspell hunspell-fr
#+end_src

#+BEGIN_SRC emacs-lisp :tangle no
(setq ispell-dictionary "en_US,fr_FR")
(setq ispell-program-name "hunspell")
(setq ispell-silently-savep t)
(setq ispell-personal-dictionary **local-personal-dictionary**)
;; Please note ispell-extra-args contains ACTUAL parameters passed to aspell
;; (setq ispell-extra-args '("--sug-mode=ultra"))
(ispell-set-spellchecker-params)
(ispell-hunspell-add-multi-dic "en_US,fr_FR")
(add-hook 'org-mode-hook 'turn-on-flyspell)
(eval-after-load "flyspell"
     '(diminish 'flyspell-mode))
#+END_SRC

For most documents, aim for a score of approximately 60 to 70 for
the reading ease and 7.0 to 8.0 for the grade level.
#+BEGIN_SRC emacs-lisp
(use-package writegood-mode)
#+END_SRC

If you need additional feedback from an external service here is an
easy way to do it:
#+BEGIN_SRC emacs-lisp
(require 'browse-url) ; part of gnu emacs

(defun my-lookup-wikipedia ()
  "Look up the word under cursor in Wikipedia.
If there is a text selection (a phrase), use that.

This command switches to browser."
  (interactive)
  (let (word)
    (setq word
          (if (use-region-p)
              (buffer-substring-no-properties (region-beginning) (region-end))
            (current-word)))
    (setq word (replace-regexp-in-string " " "_" word))
    (browse-url (concat "http://en.wikipedia.org/wiki/" word))
    ;; (eww myUrl) ; emacs's own browser
    ))
#+END_SRC

* Search
Searching is probably the most important thing in a code editor.
Here is how I search.

** Search in current file/buffer

isearch and occur (~M-s o~)

** Search in project

=C-c s=
#+BEGIN_SRC emacs-lisp
(use-package rg
  :config
  (rg-enable-default-bindings))
#+END_SRC

*** From Dired
~C-x d~ to launch dired . I mark the files I am interested in with
~m~. Then I can grep those files with ~A~ and do a query replace
with ~Q~.
** Rename

#+BEGIN_SRC emacs-lisp
(use-package iedit)
#+END_SRC

* VCS
Don't forget Emacs vcs features accessible with the prefix ~C-x v~!

** Resolving conflicts

This is to prevent popup windows when resolving file conflicts.
I prefer to have the ediff take over and restove the windows when
done.
#+BEGIN_SRC emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
(add-hook 'ediff-after-quit-hook-internal 'winner-undo)
(setq ediff-split-window-function 'split-window-vertically)
#+END_SRC

** Working with GitHub

To grab a link I can share with co-workers from the region or file.
#+BEGIN_SRC emacs-lisp
(use-package git-link :bind (("C-c gl" . git-link)))
#+END_SRC

Otherwise I launch a ~gitsh~ session and I use [[https://github.com/github/hub][hub]] to interact with
github directly

** View History
*** timemachine
Allows to view previous versions of a file. It is not focused on the
diff but on the file itself. Use ~n~ and ~p~ to navigate between
versions.
#+BEGIN_SRC emacs-lisp
(use-package git-timemachine
  :bind (("C-c gt" . git-timemachine-toggle)))
#+END_SRC
*** vc-annotate

Bound to ~C-x v g~.
- Use ~l~ to see the commit message
- ~f~ to see what the file looked like at that revision. You can
  then use /git-link/ to grab a link with ~C-c gl~
- ~n~ and ~p~ to navigate between revisions
- ~=~ to see the diff.

  I prefer to use a full-window with vc-annotate
  #+BEGIN_SRC emacs-lisp
  (use-package fullframe
    :config
    (fullframe vc-annotate quit-window))
  #+END_SRC

** Magit

#+BEGIN_QUOTE
[[https://magit.vc/][Magit]] is an interface to the version control system Git, implemented
as an Emacs package. Magit aspires to be a complete Git porcelain.
While we cannot (yet) claim that Magit wraps and improves upon each
and every Git command, it is complete enough to allow even
experienced Git users to perform almost all of their daily version
control tasks directly from within Emacs. While many fine Git
clients exist, only Magit and Git itself deserve to be called
porcelains.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind (("C-c gs" . magit-status)
           ("C-c gc" . magit-commit)
           ("C-c gp" . magit-push-current)
           ("C-c gf" . magit-file-dispatch))
    :init
    (setq magit-commit-show-diff nil
          magit-auto-revert-mode nil
          magit-commit-show-diff nil))
#+END_SRC

When I use magit, I prefer to have it use the full emacs frame
instead of splitting the current buffer.
#+BEGIN_SRC emacs-lisp
(use-package fullframe
  :after magit
  :config
  (fullframe magit-status magit-mode-quit-window))
#+END_SRC

** gitsh

#+BEGIN_QUOTE
The [[https://github.com/thoughtbot/gitsh][gitsh]] program is an interactive shell for git. From within
gitsh you can issue any git command, even using your local aliases
and configuration
#+END_QUOTE

When I have to do git related things that are painful to do with
magit, I just fire a terminal with /gitsh/ for the current project.

** Visual enhancements

See in the fringe lines added, changed and removed since last commit.
#+BEGIN_SRC emacs-lisp :tangle no
(use-package diff-hl
  :after magit
  :config
  (add-hook 'prog-mode-hook 'diff-hl-mode)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
#+END_SRC

* Projects
Emacs is not an IDE but I can be pretty close to one.
Here are some tools I use that are IDE oriented.

Emacs now includes ~project.el~ which helps managing projects

~C-x p~ as the default keybinding map
#+BEGIN_SRC emacs-lisp
(require 'project)
#+END_SRC

** Jump
/dumb-jump/ just do a search through the project to try to guess the
correct jump location for the current symbol. It is not has good as an
IDE code analysis but it works surprisingly well.

~M-.~ or ~gd~ to search from normal mode
~M-,~ to go back.
~M-?~ to find references
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-.") 'xref-find-definitions)
(use-package dumb-jump
  :init
  (setq dumb-jump-selector 'ivy)
  :config
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+END_SRC

** Navigation tree
#+begin_src emacs-lisp
 (setq speedbar-directory-unshown-regexp "^$")
 (global-set-key (kbd "C-c b") 'speedbar-get-focus)
#+end_src

* Completion
** Hippie expand
Bound to ~s-/~, it provides a simple on demand completion mechanism.
You can customize its behaviour by choosing different expand functions.

The description of all the hippie expand functions is inside
[[https://github.com/emacs-mirror/emacs/blob/master/lisp/hippie-exp.el#L63][~hippie-exp.el~]] (location can vary on your system)
#+BEGIN_SRC emacs-lisp
(setq hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-from-kill try-expand-all-abbrevs try-expand-list))
(require 'mode-local)
(setq-mode-local elisp-mode hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-from-kill try-expand-list try-complete-lisp-symbol-partially try-complete-lisp-symbol))
(setq-mode-local elisp-mode hippie-expand-try-functions-list '(try-expand-dabbrev try-expand-dabbrev-from-kill try-expand-all-abbrevs try-complete-lisp-symbol-partially try-complete-lisp-symbol))
#+END_SRC

** Auto-Completion

company shows a popup where you can select completions with a number
or with ~enter~. You can also invoke the popup manually with ~C-x
C-o~

Use =company-diag= to debug completion problems
#+BEGIN_SRC emacs-lisp
(use-package company
  :diminish company-mode
  :config
  (setq company-idle-delay 0.2
        company-tooltip-limit 10
        company-tooltip-align-annotations t
        company-require-match 'never
        company-global-modes '(not eshell-mode comint-mode erc-mode message-mode help-mode gud-mode)
        company-frontends '(company-pseudo-tooltip-frontend company-echo-metadata-frontend)
        company-backends '((company-files company-capf))
        company-transformers '(company-sort-by-occurrence))

  (add-hook 'after-init-hook 'global-company-mode)
  (setq company-dabbrev-downcase nil
        company-dabbrev-ignore-case nil)
  (setq company-show-numbers t)

  (use-package company-statistics
    :after company
    :config
    (setq company-statistics-file "~/.emacs.d/company-stats-cache.el")
    (company-statistics-mode +1))
      ;;; Prevent suggestions from being triggered automatically. In particular,
  ;;; this makes it so that:
  ;;; - TAB will always complete the current selection.
  ;;; - RET will only complete the current selection if the user has explicitly
  ;;;   interacted with Company.
  ;;; - SPC will never complete the current selection.
  ;;;
  (dolist (key '("<return>" "RET"))
    ;; Here we are using an advanced feature of define-key that lets
    ;; us pass an "extended menu item" instead of an interactive
    ;; function. Doing this allows RET to regain its usual
    ;; functionality when the user has not explicitly interacted with
    ;; Company.
    (define-key company-active-map (kbd key)
      `(menu-item nil company-complete
                  :filter ,(lambda (cmd)
                             (when (company-explicit-action-p)
                               cmd)))))
  (define-key company-active-map (kbd "TAB") #'company-complete-selection)
  (define-key company-active-map (kbd "SPC") nil)
  (autoload 'company-capf "company-capf")
  (autoload 'company-yasnippet "company-yasnippet")
  (autoload 'company-elisp "company-elisp")
  (autoload 'company-files "company-files"))

(use-package company-box
  :hook (company-mode . company-box-mode))


#+END_SRC

** Snippets
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :defer 3
  :commands yas-expand-snippet
  :bind (("C-c y" . yas-insert-snippet))
  :diminish yas-minor-mode
  :init
  (setq yas-snippet-dirs
        '("~/.emacs.d/snippets"))
  :config
  (yas-global-mode 1)
  (add-hook 'term-mode-hook (lambda()
                              (yas-minor-mode -1))))
#+END_SRC

This allow me to automatically expand [[https://github.com/aurelienbottazini/dotfiles/blob/master/emacs/.emacs.d/templates/][templates]] into new files using
the yasnippet format. The filenames for the template are regexes.
#+BEGIN_SRC emacs-lisp :tangle no
(use-package yatemplate
  :config
  (add-hook 'find-file-hook 'auto-insert)
  (yatemplate-fill-alist))
#+END_SRC

* Files and directories
To play a video, with cursor on video file in dired =! vlc=

** Dired
#+BEGIN_SRC emacs-lisp
(setq ls-lisp-use-insert-directory-program t) ;same ls-lisp for Dired regardless of the platform
(setq dired-listing-switches "-alh")
;; on mac there is some weird prefixing going on for GNU Tools like ls.
;; I favor GNU ls over MacOSX default ls
(when (string-equal system-type "darwin")
  (setq insert-directory-program "gls"))

(require 'dired )
(defun my-dired-mode-setup ()
  "to be run as hook for `dired-mode'."
  (dired-hide-details-mode 1))
(add-hook 'dired-mode-hook 'my-dired-mode-setup)

(put 'dired-find-alternate-file 'disabled nil)
(setq dired-dwim-target t)
(add-hook 'dired-load-hook
          (lambda ()
            (load "dired-x")
            ;; Set dired-x global variables here.  For example:
            ;; (setq dired-guess-shell-gnutar "gtar")
            ;; (setq dired-x-hands-off-my-keys nil)
            (setq dired-recursive-copies (quote always)) ; “always” means no asking
            (setq dired-recursive-deletes (quote top)) ; “top” means ask once
            ))

(eval-after-load "dired"
  '(progn
     (define-key dired-mode-map "-" 'dired-up-directory)))

(use-package dired-rsync
:bind (:map dired-mode-map ("p" . dired-rsync)))
#+END_SRC

* 24 bits Emacs

Run this command to know if your Emacs display 24 bits colors.
Result should be 16777216
#+begin_src emacs-lisp :tangle no
(display-color-cells)
#+end_src

On Ubuntu 20.04 I had to [[https://github.com/aurelienbottazini/dotfiles/blob/dc400917364c9cc61d804e6d88c2c11b63da1c3c/home/.config/shell/aliases#L29][add a TERM env variable]] and add the
corresponding =terminfo= entry
#+begin_src shell
tic -o ~/.terminfo -x ~/.emacs.d/terminfo-emacs-rgb.src
#+end_src

Other =terminfo= examples are available on the [[https://www.gnu.org/software/emacs/manual/html_mono/efaq.html#Colors-on-a-TTY][emacs manual]]

* Documentation
#+BEGIN_SRC emacs-lisp
  (use-package engine-mode
    :bind (("C-c d c" . engine/search-caniuse)
           ("C-c d m" . engine/search-mdn)
           ("C-c d ra" . engine/search-rails)
           ("C-c d rr" . engine/search-ruby))
    :config
    (defengine ruby "https://apidock.com/ruby/search?query=%s")
    (defengine rails "https://api.rubyonrails.org/?q=%s")
    (defengine mdn "https://developer.mozilla.org/en-US/search?q=%s")
    (defengine caniuse "https://caniuse.com/#search=%s")
    )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package restclient
  :demand t
  :config
  (add-to-list 'auto-mode-alist '("\\.http\\'" . restclient-mode)))
#+END_SRC

* Presentation
#+begin_src emacs-lisp
(defun abott/org-tree-slide-play ()
  (writeroom-mode 1)
  (default-text-scale-increment 40))
(defun abott/org-tree-slide-stop ()
  (writeroom-mode -1)
  (default-text-scale-reset))

(use-package org-tree-slide
  :hook ((org-tree-slide-play . abott/org-tree-slide-play)
         (org-tree-slide-stop . abott/org-tree-slide-stop))
  :bind (("<f7>" . org-tree-slide-mode)
         ("S-<f7>" . org-tree-slide-skip-done-toggle))
  :config
  (with-eval-after-load "org-tree-slide"
    (define-key org-tree-slide-mode-map (kbd "<f8>") 'org-tree-slide-move-previous-tree)
    (define-key org-tree-slide-mode-map (kbd "<f9>") 'org-tree-slide-move-next-tree)))
#+end_src

C-c C-e R =letter= to export a presentation from your org file

#+begin_src emacs-lisp
(use-package ox-reveal
  :config
  (setq org-reveal-root "file:///Users/auray/.emacs.d/site-lisp/reveal.js-4.1.0"))
#+end_src

* Testing

#+begin_src emacs-lisp
(use-package docker-tramp)
#+end_src

#+begin_src emacs-lisp
(use-package evil
:config
(evil-mode 1))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package ivy
:init
(setq counsel-grep-base-command
 "rg -i -M 120 --no-heading --line-number --color never '%s' %s")
(setq ivy-use-virtual-buffers t)
(setq enable-recursive-minibuffers t)
;; enable this if you want `swiper' to use it
;; (setq search-default-mode #'char-fold-to-regexp)
:config
(ivy-mode)
(use-package counsel)
(global-set-key "\C-s" 'swiper)
(global-set-key (kbd "C-c C-r") 'ivy-resume)
(global-set-key (kbd "<f6>") 'ivy-resume)
(global-set-key (kbd "M-x") 'counsel-M-x)
(global-set-key (kbd "C-x C-f") 'counsel-find-file)
(global-set-key (kbd "<f1> f") 'counsel-describe-function)
(global-set-key (kbd "<f1> v") 'counsel-describe-variable)
(global-set-key (kbd "<f1> o") 'counsel-describe-symbol)
(global-set-key (kbd "<f1> l") 'counsel-find-library)
(global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
(global-set-key (kbd "<f2> u") 'counsel-unicode-char)
(global-set-key (kbd "C-x l") 'counsel-locate)
(global-set-key (kbd "C-c b") 'counsel-bookmark)
(define-key minibuffer-local-map (kbd "C-r") 'counsel-minibuffer-history)
)

(use-package evil
:config
  (evil-set-initial-state 'ivy-occur-grep-mode 'emacs)
)
#+end_src

~counsel-rg~ is my main way to search. Invoked with an argument, it
allows you to specify the directory and search options.
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :bind (("C-c f" . counsel-rg)))
#+END_SRC

When I am investigating things, I like to see a preview of the
results as I scroll down the search results. I do it with ~C-o~ then
either ~g~ on the entry I want to preview or ~c~ to automatically
preview results as I move through the result list.

A trick I am learning is to use ~C-'~ to jump directly to a
search results.

*** When I need to narrow down my search to specific files

**** Narrowing on the file-type

Launch ~counsel-rg~ with a prefix and then I can use for example
~-tjs~ as an argument to search only inside javascript files.
~-Tjs~ searches inside files but javascript ones.

**** From Dired
~C-x d~ to launch dired . I mark the files I am interested in with
~m~. Then I can grep those files with ~A~ and do a query replace
with ~Q~.


Move between buffers with C-h C-j C-k C-l. My Tmux bindings are made
to [[https://github.com/aurelienbottazini/dotfiles/blob/6cb8e100568cffb788f0ecd8488e4a4fd50349cd/tmux/.config/tmux/tmux.conf#L31-L35][make it work seamlessly]] with Emacs.
#+begin_src emacs-lisp
(defun tmux-socket-command-string ()
  (interactive)
  (concat "tmux -S "
          (replace-regexp-in-string "\n\\'" ""
                                    (shell-command-to-string "echo $TMUX | sed -e 's/,.*//g'"))))

(defun tmux-move-right ()
  (interactive)
  (condition-case nil
      (evil-window-right 1)
    (error (unless window-system (shell-command (concat
                                                 (tmux-socket-command-string) " select-pane -R") nil)))))

(defun tmux-move-left ()
  (interactive)
  (condition-case nil
      (evil-window-left 1)
    (error (unless window-system (shell-command (concat
                                                 (tmux-socket-command-string) " select-pane -L") nil)))))

(defun tmux-move-up ()
  (interactive)
  (condition-case nil
      (evil-window-up 1)
    (error (unless window-system (shell-command (concat
                                                 (tmux-socket-command-string) " select-pane -U") nil)))))

(defun tmux-move-down ()
  (interactive)
  (condition-case nil
      (evil-window-down 1)
    (error (unless window-system (shell-command (concat
                                                 (tmux-socket-command-string) " select-pane -D") nil)))))

(global-set-key (kbd "C-h") 'tmux-move-left)

(global-set-key (kbd "C-j") 'tmux-move-down)
(define-key org-mode-map (kbd "C-j") 'tmux-move-down)

(global-set-key (kbd "C-k") 'tmux-move-up)
(global-set-key (kbd "C-l") 'tmux-move-right)
(use-package evil-commentary
:config
(evil-commentary-mode +1))

(use-package evil-visualstar
:config
(global-evil-visualstar-mode +1))

#+END_SRC

I started using Vim to help me prevent [[https://www.emacswiki.org/emacs/RepeatedStrainInjury][emacs RSI.]]
Now I am sticking with it because It makes me feel like beethoven
manipulating text :-)

Here is an awesome [[https://github.com/noctuid/evil-guide][Evil Guide]]

Quit read-only windows with Q instead of trying to register a Vim
Macro.
This is mainly to restore emacs behavior with help windows.
#+BEGIN_SRC emacs-lisp
(use-package evil
  :config
  (defun my-evil-record-macro ()
    (interactive)
    (if buffer-read-only
        (quit-window)
      (call-interactively 'evil-record-macro)))

  (with-eval-after-load 'evil-maps
    (define-key evil-normal-state-map (kbd "q") 'my-evil-record-macro)))

#+END_SRC

Surround things with
- ~S~ in visual mode
- ~ys<text-object>~ in normal mode
  You can also change surroundings ~cs~ or delete surroundings ~ds~.
#+BEGIN_SRC emacs-lisp
(use-package evil-surround
  :after evil
  :config
  (global-evil-surround-mode 1))
#+END_SRC

I use Vim keybindings everywhere except with special modes

like Magit, Dired... I setup those special modes to start with Emacs
keybindings by default.
#+begin_src emacs-lisp
(use-package evil
  :config
  (evil-set-initial-state 'deft-mode 'insert)
  (evil-set-initial-state 'dired-mode 'normal)
  (evil-set-initial-state 'magit-mode 'emacs)
  (evil-set-initial-state 'use-package-statistics 'emacs)
  (evil-set-initial-state 'xref--xref-buffer-mode 'emacs)
  (evil-set-initial-state 'term-mode 'emacs)
  (evil-set-initial-state 'ert-results-mode 'emacs))
#+end_src

  Comment things with ~gc~. Comment and copy with ~gy~
  #+BEGIN_SRC emacs-lisp
  (use-package evil-commentary
    :after evil
    :diminish evil-commentary-mode
    :config
    (evil-commentary-mode))
  #+END_SRC

  Start a search from visual selection with ~*~ or ~#~ (backward).
  #+BEGIN_SRC emacs-lisp
  (use-package evil-visualstar
    :after evil
    :config
    (global-evil-visualstar-mode t))
  #+END_SRC

  Jump to matching pairs with ~%~.
  #+BEGIN_SRC emacs-lisp
  (use-package evil-matchit
    :defer 2
    :after evil
    :config
    (global-evil-matchit-mode 1))
  #+END_SRC

  Persist highlight from ~evil search~ and ~isearch~
  #+BEGIN_SRC emacs-lisp
  (use-package evil-search-highlight-persist
    :bind  (("C-c oh" . (lambda ()
                              (interactive)
                              (hi-lock-mode -1) (evil-search-highlight-persist-remove-all))
                 )
                )
    :config
    (global-evil-search-highlight-persist t))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
  (use-package evil
    :config
    (evil-mode 1)
    (evil-ex-define-cmd "W" 'save-buffer))
  #+END_SRC

  Add text objects to select, copy things based on indentation level.
  Use it with ~vii~ and ~yii~.
  #+BEGIN_SRC emacs-lisp
  (use-package evil-indent-plus
    :after evil
    :config
    (evil-indent-plus-default-bindings))
  #+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package evil
  :config
  (setq evil-want-C-i-jump nil)
  (evil-define-key 'insert lisp-interaction-mode-map (kbd "C-c C-c") 'eval-print-last-sexp))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package key-chord
  :defer 2
  :after evil
  :config
  (key-chord-mode 1)
  (key-chord-define evil-insert-state-map  "jk" 'evil-normal-state))
#+END_SRC

#+begin_src emacs-lisp
(use-package ace-window
:config
(global-set-key (kbd "C-x o") 'ace-window))
#+end_src

** Find file in project
*** Examples
#+BEGIN_SRC emacs-lisp :tangle no
;; if the full path of current file is under SUBPROJECT1 or SUBPROJECT2
;; OR if I'm reading my personal issue track document,
(defun my-setup-develop-environment ()
  (interactive)
  (when (ffip-current-full-filename-match-pattern-p "\\(PROJECT_DIR\\|issue-track.org\\)")
    ;; Though PROJECT_DIR is team's project, I care only its sub-directory "subproj1""
    (setq-local ffip-project-root "~/projs/PROJECT_DIR/subproj1")
    ;; well, I'm not interested in concatenated BIG js file or file in dist/
    (setq-local ffip-find-options "-not -size +64k -not -iwholename '*/dist/*'")
    ;; for this project, I'm only interested in certain types of files
    (setq-local ffip-patterns '("*.html" "*.js" "*.css" "*.java" "*.xml" "*.js"))
    ;; maybe you want to search files in `bin' directory?
    (setq-local ffip-prune-patterns (delete "*/bin/*" ffip-prune-patterns))
    ;; exclude `dist/' directory
    (add-to-list 'ffip-prune-patterns "*/dist/*"))
  ;; insert more WHEN statements below this line for other projects
  )

;; most major modes inherit from prog-mode, so below line is enough
(add-hook 'prog-mode-hook 'my-setup-develop-environment)
#+END_SRC

All variables may be overridden on a per-directory basis in your
.dir-locals.el. See (info “(Emacs) Directory Variables”) for
details.

You can place .dir-locals.el into your project root directory.

A sample .dir-locals.el,

#+BEGIN_SRC emacs-lisp :tangle no
((nil . ((ffip-project-root . "~/projs/PROJECT_DIR")
         ;; ignore files bigger than 64k and directory "dist/" when searching
         (ffip-find-options . "-not -size +64k -not -iwholename '*/dist/*'")
         ;; only search files with following extensions
         (ffip-patterns . ("*.html" "*.js" "*.css" "*.java" "*.xml" "*.js"))
         (eval . (progn
                   (require 'find-file-in-project)
                   ;; ignore directory ".tox/" when searching
                   (setq ffip-prune-patterns `("*/.tox/*" ,@ffip-prune-patterns))
                   ;; Do NOT ignore directory "bin/" when searching
                   (setq ffip-prune-patterns `(delete "*/bin/*" ,@ffip-prune-patterns))))
         )))
#+END_SRC

*** My configuration

#+BEGIN_SRC emacs-lisp :tangle no
(use-package find-file-in-project
  :ensure t
  :bind (("C-c T" . find-file-in-project-by-selected)
         ("C-c t" . ffip)
         ("M-p" . ffip)
               :map evil-normal-state-map
               ("gf" . find-file-in-project-at-point))
  :config

  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.png")) ffip-ignore-filenames))
  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.jpg")) ffip-ignore-filenames))
  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.jpeg")) ffip-ignore-filenames))
  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.gif")) ffip-ignore-filenames))
  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.bmp")) ffip-ignore-filenames))
  (setq ffip-ignore-filenames (seq-remove (lambda (astring) (string= astring "*.ico")) ffip-ignore-filenames))
  (setq ffip-prefer-ido-mode nil)
  (setq ffip-use-rust-fd t)
  (setq ffip-strip-file-name-regex "\\(\\.mock\\|_test\\|\\.test\\|\\.mockup\\|\\.spec\\)")
  (add-to-list 'ffip-prune-patterns "*/.git/*")
  (add-to-list 'ffip-prune-patterns "*/dist/*")
  (add-to-list 'ffip-prune-patterns "*/.emacs.d/elpa/*")
  (add-to-list 'ffip-prune-patterns "*/.nuxt/*")
  (add-to-list 'ffip-prune-patterns "*/spec/coverage/*")
  (add-to-list 'ffip-prune-patterns "*/public/*")
  (add-to-list 'ffip-prune-patterns "*/.shadow-cljs/*")
  (add-to-list 'ffip-prune-patterns "*/vendor/*")
  (add-to-list 'ffip-prune-patterns "node_modules/*"))
#+END_SRC

#+begin_src emacs-lisp
(setq project-switch-commands 'project-dired)

(global-set-key (kbd "C-c t") 'project-find-file)
(global-set-key (kbd "M-p") 'project-find-file)

(use-package el-patch)
(el-patch-defun project--files-in-directory (dir ignores &optional files)
  (el-patch-remove
    (require 'find-dired)
    (require 'xref)
    (defvar find-name-arg))
  (let* ((default-directory dir)
         ;; Make sure ~/ etc. in local directory name is
         ;; expanded and not left for the shell command
         ;; to interpret.
         (localdir (file-local-name (expand-file-name dir)))
         (command (el-patch-swap
                    (format "%s %s %s -type f %s -print0"
                            find-program
                            localdir
                            (xref--find-ignores-arguments ignores localdir)
                            (if files
                                (concat (shell-quote-argument "(")
                                        " " find-name-arg " "
                                        (mapconcat
                                         #'shell-quote-argument
                                         (split-string files)
                                         (concat " -o " find-name-arg " "))
                                        " "
                                        (shell-quote-argument ")"))
                              ""))
                    (format "fd -t f -0 . %s" localdir))))
    (project--remote-file-names
     (sort (split-string (shell-command-to-string command) "\0" t)
           #'string<))))
#+end_src

#+begin_src emacs-lisp :tangle no
(if (and (fboundp 'native-comp-available-p)
       (native-comp-available-p))
  (message "Native compilation is available")
(message "Native complation is *not* available"))
#+end_src

#+begin_src emacs-lisp :tangle no
(if (functionp 'json-serialize)
  (message "Native JSON is available")
(message "Native JSON is *not* available"))
#+end_src

#+begin_src emacs-lisp
(global-set-key (kbd "M-[") 'tab-bar-history-back)
(global-set-key (kbd "M-]") 'tab-bar-history-forward)
(tab-bar-history-mode +1)

;; (global-tab-line-mode +1)
#+end_src

LSP (language server)
#+begin_src emacs-lisp
(use-package eglot)
#+end_src

#+begin_src emacs-lisp
(defun auray/project-guess-file ()
  "Visit a file (with completion) in the current project.

The filename at point (determined by `thing-at-point'), if any,
is available as part of \"future history\"."
  (interactive)
  (let* ((pr (project-current t))
         (dirs (list (project-root pr))))
  (counsel-fzf (current-word) (project-root (project-current t)))))

(setq counsel-fzf-cmd "fd --type f | fzf -f \"%s\"")

(evil-define-key nil evil-normal-state-map (kbd "gf") 'auray/project-guess-file)
#+end_src

* Local variables

# Local Variables:
# eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
# End:




